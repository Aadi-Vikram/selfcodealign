### System: I->R
Provide the best response to a given instruction. Follow the following steps to craft your response:
1. reason about the given instruction
2. provide a high-quality solution
3. offer a concise explanation
4. write assertions and **invoke them** to verify the correctness your solution

### System: C->I
Create a set of independent code instructions that are original, different, diverse, and high-quality, where the properties control an instruction's category, language, concepts, and difficulty.

### System: S->C
Extract key programming concepts from a given code snippet collected from the open source repositories. Present the concepts as a comma separated list.

### Example 1
[Code]
    value = int(round((value - prev) * 1e5))
    value = ~(value << 1) if value < 0 else (value << 1)
    chunks = _split_into_chunks(value)
    return (chr(chunk + 63) for chunk in chunks)
def _split_into_chunks(value):
    while value >= 32:  # 2^5, while there are at least 5 bits
        # first & with 2^5-1, zeros out all the bits other than the first five
        # then OR with 0x20 if another bit chunk follows
        yield (value & 31) | 0x20
        value >>= 5

[Property]
category: code generation (function implementation)
language: Python
concepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling

[Instruction]
Create a Python function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.

[Response]
[Reasoning]
To encode an integer into a sequence of encoded characters based on the specified criteria, let's follow these steps:

1. Break down the integer into 5-bit chunks: Extract 5-bit chunks from the integer using using `& 31` (`0x1F`), because the binary representation of `31` (`11111`) has the last five bits set, which will effectively extract the 5 bits we are interested in. We start from the least significant bits (LSB).
2. Set continuation bit: For all chunks except the last one, set the 6th bit to 1 using `| 32` (`0x20`) because the binary representation of `32` (`100000`) has the 6th bit set to 1. This indicates that there's another continuation chunk following.
3. Shift right: Right-shift the value by 5 to process the next 5 bits.
4. Convert to characters: Use `ord` and `chr` to convert each chunk (now effectively 6 bits due to the continuation bit) into a character by adding 63 to its value. This ensures that the character is within a printable ASCII range.
5. Assembly: Assemble these characters into the final encoded string while maintaining the order of the chunks through `reversed`.

[Implementation]
Here's how you can implement this function:

```python
def encode_integer_to_chars(value: int) -> str:
    if value == 0:
        return chr(63)

    encoded_chars = []
    while value > 0:
        chunk = (value & 31) + 63
        value >>= 5
        if value > 0:
            chunk |= 32
        encoded_chars.append(chr(chunk))

    return ''.join(reversed(encoded_chars))
```

[Explanation]
This function processes the integer bit by bit in 5-bit chunks, applying bitwise operations to extract and manipulate these chunks, then converts each chunk into a character using the specified encoding scheme. This approach efficiently handles the encoding in a loop until all bits of the integer have been processed.

Note that this function is designed for non-negative integers and does not support negative integers by default because negative numbers are represented in two's complement form, where the most significant bit (MSB) indicates the sign. In Python, right-shifting (`>>`) a negative integer preserves the sign bit, effectively making the never executed due to the `value > 0` condition. If you change it to `value != 0`, it will then lead to an infinite loop if the same encoding logic is applied to negative integers without modifications.

[Tests]
You can validate this function with a few test cases to ensure correctness:

```python
assert encode_integer_to_chars(0) == chr(63)
assert encode_integer_to_chars(1) == chr(63 + 1)
assert encode_integer_to_chars(31) == chr(63 + 31)
assert encode_integer_to_chars(int(0b1)) == chr(0b1 + 63)
assert encode_integer_to_chars(int(0b1000001)) == chr(0b10 + 63) + chr(63 + 0b100001)
```

These tests cover scenarios from zero to a number requiring more than one chunk, ensuring the function operates as expected.

### Example 2
[Code]
def ceil_shift(n, b):
    """Return ceil(n / 2**b) without performing any floating-point or division operations.
    This is done by right-shifting n by b bits and incrementing the result by 1
    if any '1' bits were shifted out.
    """
    if not isinstance(n, int) or not isinstance(b, int):
        raise TypeError("unsupported operand type(s): %r and %r" % (type(n).__name__, type(b).__name__))
    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values
    mask = (1 << b) - 1
    if n & mask:
        return (n >> b) + 1
    else:

[Property]
category: code generation (function implementation)
language: Python
concepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks

[Instruction]
Develop a Python function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.

[Response]
[Reasoning]
We can leverage the properties of bitwise operations to develop a Python function that computes the ceiling of `n / 2**b` without using division, floating-point operations, or any built-in functions like `math.ceil`, and strictly avoiding converting the problem into a floor computation.

In the context, dividing by `2**b` is equivalent to right-shifting `n` by `b` bits in binary representation when `n` is divisible by `2**b`. Otherwise, this approach inherently computes the floor of the division. To adjust for the ceiling without directly calculating it, we can consider two cases:

1. If `n` is divisible by `2**b`, the result of the division is simply the value of right-shifting `n` by `b` bits.
2. Otherwise, we need to increment the right-shifted result by 1 to achieve the ceiling effect.

To determine the divisibility of `n` by `2**b`, we can check if the first `b` bits of `n` are all 0. This can be done using a mask with the first `b` bits set to 1, and then performing a bitwise AND operation with `n`. If the result is 0, it indicates that `n` is divisible by `2**b`. The mask can be created using `mask = (1 << b) - 1`.

We'll also include assertions to ensure that `n` and `b` are non-negative integers.

[Implementation]
Here is the implementation of `ceil_divide_without_div`:

```python
def ceil_divide_without_div(n: int, b: int) -> int:
    assert isinstance(n, int) and n >= 0, "n must be a non-negative integer"
    assert isinstance(b, int) and b >= 0, "b must be a non-negative integer"

    mask = (1 << b) - 1
    divisible = (n & mask) == 0
    result = n >> b
    if not divisible:
        result += 1
    return result
```

[Explanation]
This function calculates the ceiling of `n / 2**b` purely through bitwise manipulation and integer arithmetic. The assertions ensure the input constraints are met, as specified.

[Tests]
To verify the correctness of the function, we can run the following tests:

```python
import math

assert ceil_divide_without_div(10, 3) == math.ceil(10 / 2**3)
assert ceil_divide_without_div(17, 4) == math.ceil(17 / 2**4)
assert ceil_divide_without_div(100, 5) == math.ceil(100 / 2**5)
assert ceil_divide_without_div(0, 3) == math.ceil(0 / 2**3)
assert ceil_divide_without_div(1, 0) == math.ceil(1 / 2**0)
```

These tests compare the results of our function with the expected results obtained using `math.ceil` to ensure the correctness of the ceiling division operation.

### Example 3
[Code]
    isprime = n >= 2 and 1 or 0
    for prime in prime_list:                    # Check for factors with all primes
        if prime * prime > n: break             # ... up to sqrt(n)
        if not n % prime:
            isprime = 0
            break
    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup
    return isprime
def prime(x):
    ''' Returns the xth prime '''
    lastn = prime_list[-1]
    while len(prime_list) <= x:                 # Keep working until we've got the xth prime
        lastn = lastn + 1                       # Check the next number

[Property]
category: code generation (class implementation)
language: Python
concepts: prime number memoization, n-th prime calculation, efficiency in prime checks

[Instruction]
Implement a Python class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.

[Response]
[Reasoning]
Implementing the required Python class with the method `find_nth_prime_memoized(n)` involves several key steps:

1. The class should have a constructor `__init__` that initializes the cache list to store the memoized prime numbers. Initially, the list can be seeded with the first two prime numbers, 2 and 3.
2. The method `find_nth_prime_memoized` will check if the requested `n`th prime is already in the memoized list. If it is, it will return that prime directly. If not, it will start from the last cached prime and continue to find and cache new primes until the `n`th prime is found.
3. A helper method `is_prime` can be defined to check if a number is prime. To efficiently check for primality:
    - It checks if the number is divisible by each of the primes already in the cache.
    - It only checks up to the square root of the number to be tested, implemented by comparing the square of the prime with the number.
    - It skips even numbers by incrementing by 2 for each prime check. This is sound since the cache is initialized with the first **two** primes, 2 and 3.

[Implementation]
Here is how you could implement such a class:

```python
class PrimeFinder:
    def __init__(self):
        self.primes = [2, 3]

    def is_prime(self, num: int) -> bool:
        if num < 2:
            return False
        for prime in self.primes:
            if prime * prime > num:
                break
            if num % prime == 0:
                return False
        return True

    def find_nth_prime_memoized(self, n: int) -> int:
        # Return the n-th prime directly if already in cache
        if n <= len(self.primes):
            return self.primes[n - 1]

        # Start checking from the number after the last prime in cache
        current_num = self.primes[-1] + 2
        while len(self.primes) < n:
            if self.is_prime(current_num):
                # Cache the new prime
                self.primes.append(current_num)
            # Skip even numbers
            current_num += 2

        return self.primes[n - 1]
```

[Explanation]
This class `PrimeFinder` initializes with a cache of the first two primes. The `is_prime` method checks if a number is prime by dividing it with cached primes up to its square root. The `find_nth_prime_memoized` method uses this helper method to find and cache primes up to the requested `n`th one. Subsequent calls leverage cached primes for efficiency.

[Tests]
Here's how you can test this class:

```python
# Test that the class correctly finds the first few primes
first_few_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
prime_finder = PrimeFinder()
for i, prime in enumerate(first_few_primes, 1):
    assert prime_finder.find_nth_prime_memoized(i) == prime

# Test that the memoized results are returned directly
for i, prime in enumerate(first_few_primes, 1):
    assert prime_finder.find_nth_prime_memoized(i) == prime
```

These tests verify that the class correctly finds the first few primes and that subsequent calls return the memoized results directly.

### Example 4
[Code]
    return (a + 1) * (b + 1) - 1
def keys_count(a, b):
    return powerset(a, b) * 2 - a - b
def formula(k):
    if k % 2 != 0:
        return ((k + 1) ** 2) / 2 + k + 1
    else:
        return (k ** 2) / 2 + 2 * k + 1
def multiset_powerset(multiset):
    n = len(multiset)
    c = [0] * n
    while True:
        changed = False
        i = n - 1
        while i >= 0 and not changed:

[Property]
category: code generation (function implementation)
language: Python
concepts: special formula implementation, odd and even number handling, function composition

[Instruction]
Here are two special formulas:

$$
f_1(a, b) = (a + 1) \cdot (b + 1) - 1
$$

$$
f_2(k) = \begin{cases}
    \frac{(k + 1)^2}{2} + k + 1 & \text{if } k \text{ is odd} \\
    \frac{k^2}{2} + 2k + 1 & \text{if } k \text{ is even}
\end{cases}
$$

Write a Python function to return $f_2(f_1(a, b))$ for given `a` and `b`.

[Response]
[Reasoning]
Based on the formulas you provided, we can define two Python functions, `f1(a, b)` and `f2(k)`, respectively, and then combine them to calculate $f2(f1(a, b))$ for given `a` and `b`.

[Implementation]
Here is the implementation:

```python
def f1(a, b):
    return (a + 1) * (b + 1) - 1

def f2(k):
    if k % 2 == 0:  # Check if k is even
        return (k**2) / 2 + 2 * k + 1
    else:  # k is odd
        return ((k + 1)**2) / 2 + k + 1

def f1_f2_combined(a, b):
    return f2(f1(a, b))
```

[Explanation]
In this implementation:
- `f1(a, b)` calculates the first formula you've given.
- `f2(k)` calculates the second formula, with a conditional branch for whether `k` is even or odd.
- `f1_f2_combined(a, b)` uses the output of `f1(a, b)` as the input for `f2(k)` and returns the result.

[Tests]
To test this combined function, you can simply compare it with the direct application of `f2` to the result of `f1` for different values of `a` and `b`:

```python
assert f1_f2_combined(2, 3) == f2(f1(2, 3))
assert f1_f2_combined(4, 5) == f2(f1(4, 5))
assert f1_f2_combined(6, 7) == f2(f1(6, 7))
```

### Example 5
[Code]
    while left<len(arr) and ryt >= start and left <= ryt:
        mid = (left+ryt)//2
        if arr[mid] == target:
            return mid
        elif arr[mid] > target:
            ryt = mid-1
        else:
            left = mid+1
    return left
def tripletsSorting(nums, t):
    # TimeComplexity = O((n^2)logn)
    nums.sort()
    count = 0
    for i in range(len(nums)):

[Property]
category: code generation (function implementation)
language: Python
concepts: insertion point for a sorted array, optimized time complexity

[Instruction]
Design a Python function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.

For example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.

[Response]
[Reasoning]
To solve this problem efficiently and ensure logarithmic time complexity, we can use a binary search algorithm. Compared with a standard binary search that looks for an exact match, we can modify the algorithm such that when the target is not found, we return the `left` bound, which represents the index where the target can be inserted to maintain the array's sorted order. Since any valid index for insertion is acceptable, we can direclty return the index if there is an exact match.

[Implementation]
Here is a Python function that implements this approach:

```python
from typing import List

def search_insert_position(nums: List[int], target: int) -> int:
    """
    Finds the index to insert `target` into `nums` to maintain sorted order. For example,
    given `nums = [1, 3, 5, 5, 6]` and `target = 5`, this function returns either 2 or 3,
    as `target` can be inserted at index 2 or 3 to maintain the sorted order.
    """
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2

        # Directly return the index if there's an exact match
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    # At this point, `left` is the correct insertion index
    return left
```

[Explanation]
This implementation ensures that when `target` is not found, `left` represents the correct insertion index. This is because at the end of the loop, all elements to the left of `left` are smaller than `target`, all elements to the right of `left` are equal to or larger than `target`, and `left > right`. Therefore, `left` is the correct index for insertion to maintain the sorted order.

[Tests]
To test this function, you can use the example you provided:

```python
assert search_insert_position([1, 3, 5, 5, 6], 5) in [2, 3]
assert search_insert_position([1, 3, 5, 5, 6], 2) == 1
assert search_insert_position([1, 3, 5, 5, 6], 7) == 5
```

These tests cover the scenario where the target is found at multiple indices, as well as cases where the target is not present in the array but needs to be inserted at the correct position to maintain the sorted order.

### Example 6
[Code]
def decompress(self):
    source = self.compressed
    if isinstance(source, (bytes, bytearray)):
        return self.decompress_bytes()
    pos = 0
    node = self.root
    res = bytearray()

    while pos < len(source):
        code = int(source[pos])
        child = node.children[code]
        if child.is_leaf:
            res.append(child)
            node = self.root
        else:
            node = child
        pos += 1

    return bytes(res)

[Property]
category: code generation (class and function implementation)
language: Python
concepts: 

[Instruction]
Write a Python function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.

[Response]
[Reasoning]
To accomplish the Huffman decompression, we first need to define the `HuffmanNode` class, which, as required, should be a general tree structure with a `children` list and an optional `value` attribute to store the character associated with a leaf node.

Then, we'll implement the `huffman_decompress` function. This function will traverse the Huffman tree according to the bits in `compressed_data`. When it encounters a leaf node, the associated character will be appended to the result, and the traversal restarts from the root of the tree. This process continues until the entire `compressed_data` is processed.

You said that `compressed_data` is a byte array of 0/1 sequence, so I assume that each byte, not each bit, represents a step in the Huffman tree. In practice, it is more efficient

[Implementation]
Here's how we can implement this:

```python
class HuffmanNode:
    def __init__(self, value=None):
        self.value = value
        self.children = []

def huffman_decompress(compressed_data, huffman_tree):
    # Store the decompressed characters here
    result = []

    # Start traversal from the root of the Huffman tree
    node = huffman_tree

    # Each byte represents a 0/1 bit in `compressed_data`
    for bit in compressed_data:
        # Check if the node has children
        if len(node.children) > 0:
            node = node.children[int(bit)]
        # After moving to the child, check if it's a leaf node
        if len(node.children) == 0:
            result.append(node.value)
            # Reset to start from the root for the next character
            node = huffman_tree

    # Convert the result to bytes
    return "".join(result).encode()
```

[Explanation]
In this implementation, we assume that `compressed_data` is a byte array where each byte represents a 0/1 bit in the Huffman tree. We traverse the tree according to the bits in `compressed_data`, and when we reach a leaf node, we append the associated character to the result. Finally, we convert the result to `bytes` by concatenating the characters and encoding them.

[Tests]
You can test this function with a sample Huffman tree and compressed data to verify that the decompression works correctly:

```python
root = HuffmanNode()
root.children = [HuffmanNode('A'), HuffmanNode('B')]
root.children[0].children = [HuffmanNode('C'), HuffmanNode('D')]
root.children[1].children = [HuffmanNode('E'), HuffmanNode('F')]
compressed_data = bytearray([0, 1, 0, 0, 1, 1])
# 01 -> D, 00 -> C, 11 -> F
assert huffman_decompress(compressed_data, root) == b'DCF'
```

### Example 7
[Code]
def format_size(num):
    """http://stackoverflow.com/a/1094933
    """
    for x in ['bytes', 'KB', 'MB', 'GB']:
        if num < 1024.0 and num > -1024.0:
            return "%3.1f%s" % (num, x)
        num /= 1024.0
    return "%3.1f%s" % (num, 'TB')
assert format_size(1024**2 - 1) == '1024.0KB'
assert format_size(1024*512) == '512.0KB'

[Property]
category: code generation (function implementation)
language: Python
concepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation

[Instruction]
Create a Python function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: "{X.Y}{Unit}", where "Unit" is the appropriate size unit and "X.Y" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.

[Response]
[Reasoning]
To create such a function, we can use a loop to iterate through a predefined list of units (`['bytes', 'KB', 'MB', 'GB', 'TB']`) and check if the given number of bytes fits into the current unit by comparing it with 1024.0 and -1024.0 (for handling negative sizes). We'll keep dividing the number by 1024.0 until the correct unit is found where the number is less than 1024.0. Then, we'll format the result using the appropriate unit and the rounded size.

[Implementation]
```python
def format_size(size_bytes):
    units = ['bytes', 'KB', 'MB', 'GB', 'TB']
    if size_bytes == 0:
        return "0.0bytes"  # Directly return for 0 bytes to avoid division by zero in loop
    num = abs(size_bytes)
    unit = units[0]

    for u in units[1:]:
        if num < 1024.0:
            break
        num /= 1024.0
        unit = u

    formatted_size = f"{num:.1f}{unit}"
    return formatted_size if size_bytes >= 0 else f"-{formatted_size}"
```

[Explanation]
This implementation handles both positive and negative file sizes and returns the formatted size as a string, even though negative sizes are not common in real-world scenarios.

[Tests]
You can write the following test cases to ensure it works correctly:

```python
test = [
    (1024 ** 2, "1.0MB"),
    (1024 ** 2 - 1, "1024.0KB"),
    (1024 ** 3 * 512, "512.0GB"),
    (1024 ** 4 * 512, "512.0TB"),
]
for size, expected_output in test_data:
    assert format_size(size) == expected_output
    assert format_size(-size) == f"-{expected_output}"
```

These test cases cover both positive and negative sizes across different units to validate the correctness of the `format_size` function.

### Example 8
[Code]
def unify_stringlist(L: list):
    """ Adds asterisks to strings that appear multiple times, so the resulting
    list has only unique strings but still the same length, order, and meaning.
    For example:
        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']
    """
    assert(all([isinstance(l,str) for l in L]))
    return [L[i]+"*"*L[:i].count(L[i]) for i in range(len(L))]
assert unify_stringlist(list("abc")) == list("abc")

[Property]
category: code generation (function implementation)
language: Python
concepts: list comprehension, unique string creation, precondition checking for type validation

[Instruction]
Design a Python function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Make a precondition check through `assert` to ensure the input is a list of strings.

Solve the problem in two lines of code, one for the precondition check and the other for the main logic.

[Response]
[Reasoning]
You can achieve this functionality by first ensuring the input meets your requirements using an `assert` statement with list comprehension. Then, use another list comprehension to iterate through the input list and append `'*'` to the strings. The number of `'*'` is the number of occurrences of the string before the current index.

[Implementation]
Here's how you can do it in two lines of Python code:

```python
def encode_strings(input_list):
    assert all(isinstance(item, str) for item in input_list), "Input must be a list of strings"
    return [s + '*' * input_list[:i].count(s) for i, s in enumerate(input_list)]
```

[Explanation]
The `enumerate` function provides both the index and the string in each iteration, allowing you to count the occurrences of the string before the current index.

Note that although the function is concise, it is not the most efficient solution for large lists, as the `count` method has a time complexity of O(n) for each iteration. For larger lists, a more efficient approach might be to use a dictionary to store the counts of each string and then iterate through the list to append the appropriate number of `'*'` to each string.

[Tests]
Now you can test your function with the provided examples:

```python
assert encode_strings(['a', 'a', 'b', 'a', 'c']) == ['a', 'a*', 'b', 'a**', 'c']
assert encode_strings(['a', 'b', 'c']) == ['a', 'b', 'c']
```

### Example 9
[Code]
def _create_folds_list(data, count):
    """
    Creates folds from the given data.

    :param data: the data to fold
    :param count: the number of folds to create

    :return: a list of folds
    """

    fold_count = len(data) / count
    folds = list()

    for fold_index in range(count):
        low = int(fold_index * fold_count)
        high = int((fold_index + 1) * fold_count)

        fold = data[low:high]
        folds.append(fold)

    return folds

[Property]
category: code generation (function implementation)
language: Python
concepts: data partitioning and slicing, learning from input-output examples

[Instruction]
Construct a Python function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertion:

```python
assert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]
assert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]
assert create_folds(range(25), -5) == []
assert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]
```

[Response]
[Reasoning]
To create a Python function that generates a list of folds from given data with each fold having approximately equal length (with at most a difference of 1 between any two folds), you can follow these steps:

1. Return an empty list immediately if `count` is non-positive since it's not possible to create a valid number of folds.
2. Divide the total length of the data by `count`, rounding down, to get the minimum number of items each fold should have.
3. Calculate the remainder to see how many extra items need to be distributed among the folds. They are distributed one by one to the first `remainder` folds.
4. Use a loop to create each fold, adjusting the starting and ending indices based on the calculations above to ensure each fold has the correct number of items.

[Implementation]
Here's how you can implement this:

```python
def create_folds(data, count):
    # Return an empty list if count is non-positive
    if count <= 0:
        return []

    data_length = len(data)
    fold_size = data_length // count
    remainder = data_length % count

    folds = []
    start_index = 0

    for i in range(count):
        # Add 1 element to each of the first `remainder` folds
        end_index = start_index + fold_size + (1 if i < remainder else 0)
        folds.append(range(start_index, end_index))
        start_index = end_index

    return folds
```

[Explanation]
This implementation ensures that each fold has an equal length with at most a difference of 1 between any two folds. It handles edge cases, such as a non-positive `count`, by returning an empty list as specified.

[Tests]
You can test your code with the provided assertions to verify that the function works correctly:

```python
assert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]
assert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]
assert create_folds(range(25), -5) == []
assert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]
```

### Example 10
[Code]
def duration(string):
    match = re.match(PATTERN, string)
    if not match:
        raise ValueError('Invalid duration: {}'.format(string))

    suffix = match.group(2)
    if suffix not in SUFFIX_MAP:
        raise ValueError('Invalid duration suffix: {}'.format(string))

    return int(match.group(1)) * SUFFIX_MAP[suffix]

[Property]
category: code generation (function implementation)
language: Python
concepts: regular expression, unit conversion, error handling

[Instruction]
Create a Python function that converts a string representation of a time duration into its total number of seconds. 
The input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.
The time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).
If the input format is invalid, the function should raise a ValueError.

```python
assert parse_duration('15s') == 15
assert parse_duration('2min') == 120
assert parse_duration('1h') == 3600
assert parse_duration('1d') == 86400
try:
    parse_duration('30')
except ValueError as e:
    pass
```

[Response]
[Reasoning]
The desired function aims to transform a string representation into its total number of seconds. The implementation can be split into two parts:

Input validation:
1. The input string includes two parts: a number as the prefix and the unit as the suffix.
2. We can use regular expression to assert the prefix must be a number (d+) and suffix must be one of s/sec/m/min/h/hour/d/day.
3. If the input string cannot the regular expression, we raise a ValueError. 

Result computation:
1. Based on the matches of regular expression, we capture the number and unit part.
2. We convert the unit to seconds: 's'/'sec' -> 1 second, 'm'/'min' -> 60 seconds, 'h'/'hour' -> 3600 seconds, 'd'/'day' -> 86400 seconds.
3. We multiply the seconds of the unit and the prefix number and return it as an integer. 

[Implementation]
Here's how you can implement this:

```python
import re

def parse_duration(duration_str):
    # Define a regex pattern to match the input string
    pattern = re.compile(r"(\d+)(s|sec|m|min|h|hour|d|day)$")
    match = pattern.match(duration_str)
    
    # Raise an error if the input string does not match the pattern
    if not match:
        raise ValueError(f"Invalid duration: {duration_str}")
    
    # Extract the numeric part and the suffix from the matched groups
    value, suffix = match.groups()
    value = int(value)

    # Define a dictionary mapping suffixes to their respective number of seconds
    suffix_map = {
        's': 1, 'sec': 1,
        'm': 60, 'min': 60,
        'h': 3600, 'hour': 3600,
        'd': 86400, 'day': 86400
    }

    # Calculate and return the total number of seconds
    return value * suffix_map[suffix]
```

[Explanation]
The implementation begins by defining a regular expression pattern that expects a numeric value followed by a valid time unit suffix. 
The function then tries to match this pattern against the input string. 
If the match is successful, it extracts the numeric value and the suffix. 
A dictionary (suffix_map) maps each suffix to the number of seconds it represents. 
Using this dictionary, the function calculates the total number of seconds corresponding to the input and returns it.

[Tests]
You can test your code with the provided assertions to verify that the function works correctly:

```python
# Test additional valid inputs with different suffix representations
assert parse_duration('10sec') == 10, "Check for 'sec' suffix"
assert parse_duration('3min') == 180, "Check for 'min' suffix"
assert parse_duration('5h') == 18000, "Check for 'h' suffix"
assert parse_duration('2hour') == 7200, "Check for 'hour' suffix"
assert parse_duration('1day') == 86400, "Check for 'day' suffix"

# Test edge cases
assert parse_duration('0s') == 0, "Zero duration"
assert parse_duration('0min') == 0, "Zero minutes"

# Test inputs with leading zeros
assert parse_duration('001s') == 1, "Leading zeros"
assert parse_duration('010min') == 600, "Leading zeros with minutes"

# Test case sensitivity and invalid suffix handling
try:
    parse_duration('10S')
except ValueError:
    pass

try:
    parse_duration('2hours')
except ValueError:
    pass

try:
    parse_duration('5 mins')
except ValueError:
    pass

# Test incorrect formats
try:
    parse_duration('h1')
except ValueError:
    pass

try:
    parse_duration('100')
except ValueError:
    pass

# Test extremely large numbers
assert parse_duration('1000000s') == 1000000, "Very large number of seconds"
```

### Example 15
[Code]
class Restaurant():
    
    def __init__(self, name, cuisine_type):
        self.name = name.title()
        self.cuisine_type = cuisine_type
        self.number_served = 0

    def describe_restaurant(self):
        msg = f"{self.name} tiene los mejores {self.cuisine_type}."
        print(f"\n{msg}")

    def open_restaurant(self):
        msg = f"{self.name} Está Abierta. ¡Adelante! \n"
        print(f"\n{msg}")

    def set_number_served(self, number_served):
        self.number_served = number_served #Aquí establecemos la cantidad de clientes atendidos

    def increment_number_served(self, additional_served):
        self.number_served += additional_served #Aquí incrementamos la cantidad de clientes atendidos

[Property]
category: code generation (class implementation)
language: Python
concepts: class initialization, instance methods, encapsulation, data validation

[Instruction]
Create a Python class `Restaurant` with the following properties:
- `name`: a string representing the name of the restaurant
- `cuisine_type`: a string representing the type of cuisine served at the restaurant
- `number_served`: an integer representing the number of customers served at the restaurant (default to 0)

The class should have the following methods:
- `describe_restaurant`: prints a message describing the restaurant's name and cuisine type
- `open_restaurant`: prints a message indicating that the restaurant is open
- `set_number_served`: sets the number of customers served to a given value
- `increment_number_served`: increments the number of customers served by a given value

Ensure that the `name` and `cuisine_type` properties are properly encapsulated and that the `number_served` property is validated to only accept positive integers.

[Response]
[Reasoning]
To create a Python class `Restaurant` with the specified properties and methods, we can follow these steps:

1. Define the class `Restaurant` with the `__init__` method to initialize the properties `name`, `cuisine_type`, and `number_served` with the given values. The `name` and `cuisine_type` properties can be encapsulated by using the `@property` decorator and defining getters and setters for these properties.
2. Define the `describe_restaurant` and `open_restaurant` methods to print the appropriate messages.
3. Define the `set_number_served` and `increment_number_served` methods to set and increment the `number_served` property, respectively. Ensure that the `number_served` property is validated to only accept positive integers.

[Implementation]
Here's how you can implement this class:

```python
class Restaurant:
    def __init__(self, name, cuisine_type):
        self._name = name.title()
        self._cuisine_type = cuisine_type
        self._number_served = 0

    @property
    def name(self):
        return self._name

    @property
    def cuisine_type(self):
        return self._cuisine_type

    @property
    def number_served(self):
        return self._number_served

    @number_served.setter
    def number_served(self, value):
        if not isinstance(value, int) or value < 0:
            raise ValueError("number_served must be a positive integer")
        self._number_served = value

    def describe_restaurant(self):
        msg = f"{self.name} tiene los mejores {self.cuisine_type}."
        print(f"\n{msg}")

    def open_restaurant(self):
        msg = f"{self.name} Está Abierta. ¡Adelante! \n"
        print(f"\n{msg}")

    def set_number_served(self, number_served):
        self.number_served = number_served

    def increment_number_served(self, additional_served):
        self.number_served += additional_served
```

[Explanation]
This class `Restaurant` encapsulates the `name` and `cuisine_type` properties using the `@property` decorator and defines getters and setters for these properties. The `number_served` property is also encapsulated and validated to only accept positive integers. The methods `describe_restaurant` and `open_restaurant` print the appropriate messages, while `set_number_served` and `increment_number_served` set and increment the `number_served` property, respectively.

[Tests]
To verify the correctness of this class, we can run the following tests:

```python
restaurant = Restaurant("La Taquería", "comida mexicana")
assert restaurant.name == "La Taquería"
assert restaurant.cuisine_type == "comida mexicana"
assert restaurant.number_served == 0

restaurant.set_number_served(10)
assert restaurant.number_served == 10

restaurant.increment_number_served(5)
assert restaurant.number_served == 15

try:
    restaurant.number_served = -1
except ValueError:
    pass
else:
    raise AssertionError("number_served should not accept negative values")
```

### Example 16
[Code]
def fib(limit):
    nums = []
    current, nxt = 0, 1
    while len(nums) < limit:
        current, nxt = nxt, current + nxt
        nums.append(current)

    return nums

[Property]
category: code generation (function implementation)
language: Python
concepts: Fibonacci sequence, list manipulation, efficient memory usage

[Instruction]
Write a Python function that returns a list of the first `limit` numbers in the Fibonacci sequence. The function should use efficient memory usage by only storing the last two numbers in the sequence and updating them in each iteration. The function should also validate the input `limit` to ensure it is a positive integer.

[Response]
[Reasoning]
To generate the first `limit` numbers in the Fibonacci sequence, we can use a loop that iteratively calculates the next number in the sequence by adding the last two numbers. To efficiently use memory, we only need to store the last two numbers in the sequence and update them in each iteration. This approach avoids storing the entire sequence in memory, which can be costly for large values of `limit`.

To validate the input `limit`, we can check if it is a positive integer using `isinstance` and `>= 0`.

[Implementation]
Here's how you can implement this function:

```python
def fibonacci_sequence(limit: int) -> list:
    # Validate the input limit
    if not isinstance(limit, int) or limit < 0:
        raise ValueError("limit must be a positive integer")

    # Base case for limit = 0 and 1
    if limit == 0:
        return []
    elif limit == 1:
        return [0]

    # Initialize the list with the first two numbers in the sequence
    nums = [0, 1]

    # Keep generating numbers until the list reaches the limit
    while len(nums) < limit:
        # Calculate the next number in the sequence and append it to the list
        nums.append(nums[-1] + nums[-2])

    return nums
```

[Explanation]
This function generates the first `limit` numbers in the Fibonacci sequence by iteratively calculating the next number and appending it to the list. The function also validates the input `limit` to ensure it is a positive integer.

[Tests]
You can test this function with a few test cases to ensure correctness:

```python
assert fibonacci_sequence(0) == []
assert fibonacci_sequence(1) == [0]
assert fibonacci_sequence(2) == [0, 1]
assert fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

### Example 17
[Code]
def get_param_groups(network):
    """ get param groups """
    decay_params = []
    no_decay_params = []
    for x in network.trainable_params():
        parameter_name = x.name
        if parameter_name.endswith(".weight"):
            # Dense or Conv's weight using weight decay
            decay_params.append(x)
        else:
            # all bias not using weight decay
            # bn weight bias not using weight decay, be carefully for now x not include LN
            no_decay_params.append(x)

    return [{'params': no_decay_params, 'weight_decay': 0.0}, {'params': decay_params}]

[Property]
category: code generation (function implementation)
language: Python
concepts: neural network training, parameter groups, weight decay, bias regularization

[Instruction]
Write a Python function for a typical neural network training process that returns a list of parameter groups suitable for optimizer's option such as `torch.optim.SGD`. Iterate over network parameters to properly remove `weight_decay` from all bias parameters. If the name of neural network parameters has the suffix `.weight`, it means that these parameters are non-bias parameters; otherwise, these parameters are bias parameters.

[Response]
[Reasoning]
To transform a typical neural network into a list of parameter groups suitable for optimizer's option, we'll perform the following steps:

1. Initialize two lists to store trainable parameters that require weight decay and those that don't.
2. Loop over the network's parameters, extracting their names in each iteration.
3. Check if the parameter name ends with the suffix `.weight` using the `endswith` method. If it does, it is considered a non-bias parameter and appended to the `decay_params` list.
4. Otherwise, the parameter name doesn't end with `.weight`, we'll assume it's a bias parameter and append it to the `no_decay_params` list.
5. Once the loop is complete, return the lists of parameter groups using the appropriate options for `weight_decay` and `params`.

[Implementation]
Here's how you can implement this Python function:

```python
def get_param_groups(network):
    # Initialize lists for trainable parameters that require weight decay and those that don't
    decay_params = []
    no_decay_params = []

    # Loop over the network's parameters
    for x in network.named_parameters():
        # Extract the parameter name for later use
        parameter_name = x[0]
        if parameter_name.endswith(".weight"):
            # Non-bias parameter, using `weight_decay` option
            decay_params.append(x)
        else:
            # Bias parameter, exclude `weight_decay`
            no_decay_params.append(x)

    # Return the parameter groups using the proper options for `weight_decay` and `params`
    return [{'params': no_decay_params, 'weight_decay': 0.0}, {'params': decay_params}]
```

[Explanation]
This function iterates over the network's trainable parameters, categorizing them into parameter groups that would be appropriate for passing to an optimizer's option like `torch.optim.SGD`. The function produces two parameter groups: one with option `weight_decay` set to `0.0` for all bias parameters, and one without the option set, ultimately giving us a proper split for non-zero weight decay and zero weight decay.

[Tests]
You can test this function with the following code:

```python
import torch

# Create a dummy model
model = torch.nn.Conv2d(3, 10, kernel_size=3, padding=1)

# Obtain the parameter groups
param_groups = get_param_groups(model)
decay_params = param_groups[1]['params']
no_decay_params = param_groups[0]['params']

# Just to be safe, assert that these parameters do have these names
for param in decay_params:
    assert param[0].endswith(".weight")

for param in no_decay_params:
    assert not param[0].endswith(".weight")
```

These tests verify that the function indeed separates the trainable parameters correctly into two groups per the described criteria.

### Example 18
[Code]
def alternatingCharacters(s):
    i = 0
    j = 1
    count = 0
    while j<len(s):
        if s[j] == s[i]:
            while j<len(s) and s[j] == s[i]:
                j+=1
            count += j-i-1
        i = j
        j += 1
    return count

[Property]
category: code generation (function implementation)
language: Python
concepts: 2-pointer technique, string manipulation, counting

[Instruction]
Write a Python function that takes a string `s` and counts the minimum number of deletions required to change `s` into a string such that there are no matching adjacent characters. For example, if `s = "AABAAB"`, the function should return `2` because we can delete an `A` at positions 0 and 3 to make `s = "ABAB"` in 2 deletions. Use the two-pointer technique to efficiently traverse the string and count the number of deletions required.

[Response]
[Reasoning]
To count the minimum number of deletions required to change a string `s` into a string with no matching adjacent characters, we need several key steps as follows:

1. Initialize `i` and `j` to 0 and 1, respectively, to point to the first two characters in the string.
2. While `j` is within the bounds of the string:
    - If `s[j]` is equal to `s[i]`, we have a matching adjacent character. We'll need to delete all the characters between `i` and `j` except for one. To do this, we'll increment `j` until we find a character that is not equal to `s[i]`. The number of deletions required will be `j - i - 1` because `j` is pointing to the first character that is not equal to `s[i]`, and we need to delete all the characters between `i` and `j` except for one.
    - Update `count` by adding the number of deletions required.
    - Move `i` to `j` and increment `j` by 1 to continue traversing the string.
3. Return `count` as the minimum number of deletions required.

[Implementation]
Here's how you can implement this function:

```python
def alternating_characters(s: str) -> int:
    i = 0
    j = 1
    count = 0
    while j < len(s):
        if s[j] == s[i]:
            # Increment j until we find a character that is not equal to s[i]
            while j < len(s) and s[j] == s[i]:
                j += 1
            # Add the number of deletions required to count
            count += j - i - 1
        # Move i to j and increment j by 1
        i = j
        j += 1
    return count
```

[Explanation]
This function uses two pointers, `i` and `j`, to traverse the string and count the number of deletions required. Whenever we find a matching adjacent character, we increment `j` until we find a character that is not equal to `s[i]`. The number of deletions required will be `j - i - 1` because `j` is pointing to the first character that is not equal to `s[i]`, and we need to delete all the characters between `i` and `j` except for one. We then update `count` by adding the number of deletions required and move `i` to `j` to continue traversing the string.

[Tests]
You can test this function with a few test cases to ensure correctness:

```python
assert alternating_characters("AAAA") == 3
assert alternating_characters("BBBBB") == 4
assert alternating_characters("ABABABAB") == 0
assert alternating_characters("BABABA") == 0
assert alternating_characters("AAABBB") == 4
```

### Example 19
[Code]
def oxford_comma_text_to_list(phrase):
    """Examples:
    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']
    - 'Black and White' --> ['Black', 'White']
    - 'San Francisco and Saint Francis' -->
        ['San Francisco', 'Saint Francisco']
    """
    items = []
    for subphrase in phrase.split(', '):
        items.extend(
            [item.strip() for item in subphrase.split(' and ')])
    return items

[Property]
category: code generation (function implementation)
language: Python
concepts: string manipulation, list concatenation, whitespace trimming

[Instruction]
Write a Python function that takes a list of strings and returns a string with the items separated by commas and the last item preceded by "and". Ensure that the function can handle empty lists and lists with only one item.

[Response]
[Reasoning]
To convert a list of strings into a string with the items separated by commas and the last item preceded by "and", we can follow these steps:

1. Split the phrase at commas: Use the `split` method of strings to split the phrase at commas, resulting in a list of subphrases.
2. Split each subphrase at "and": For each subphrase, split it at the word "and" using the `split` method again. This will result in a list of items within the subphrase.
3. Trim whitespace: For each item, use the `strip` method to remove any leading or trailing whitespace.
4. Assemble the items: Use the `extend` method of lists to add the items from each subphrase to the final list.

[Implementation]
Here's how you can implement this function:

```python
def oxford_comma_text_to_list(phrase: str) -> list:
    items = []
    for subphrase in phrase.split(','):
        items.extend(
            [item.strip() for item in subphrase.split(' and ') if item.strip() != ""])
    return items
```

[Explanation]
This function uses the `split` method of strings to split the phrase at commas, resulting in a list of subphrases. For each subphrase, it splits it at the word "and" using the `split` method again, resulting in a list of items within the subphrase. The `strip` method is used to remove any leading or trailing whitespace from each item. Finally, the `extend` method of lists is used to add the items from each subphrase to the final list.

[Tests]
You can test this function with a few examples:

```python
assert oxford_comma_text_to_list('Eeeny, Meeny, Miney, and Moe') == ['Eeeny', 'Meeny', 'Miney', 'Moe']
assert oxford_comma_text_to_list('Black and White') == ['Black', 'White']
assert oxford_comma_text_to_list('San Francisco and Saint Francis') == ['San Francisco', 'Saint Francis']
```

### Example 20
[Code]
# O(n) time | O(1) space
class LinkedList:
    def __init__(self, value):
        self.value = value
        self.next = None

def findLoop(head):
        if not head and not head.next:
                return None
    slowPtr, fastPtr = head.next, head.next.next
        while slowPtr != fastPtr:
                slowPtr = slowPtr.next
                fastPtr = fastPtr.next.next
        fastPtr = head
        while fastPtr != slowPtr:
                slowPtr = slowPtr.next
                fastPtr = fastPtr.next
        return fastPtr

[Property]
category: code generation (class implementation)
language: Python
concepts: 2-pointer technique, linked list cycle detection, space complexity optimization

[Instruction]
Implement a Python class with a method `find_loop` that detects and returns the node at the beginning of a loop in a linked list, if one exists. The method should have a time complexity of O(n) and a space complexity of O(1). Assume that the linked list has at least one node and that the loop is guaranteed to exist.

[Response]
[Reasoning]
To detect a loop in a linked list, we can use the two-pointer technique, where one pointer moves at a slower pace than the other. If the linked list has a loop, the two pointers will eventually meet at some point. To determine the node at the beginning of the loop, we can use the following approach:

1. Initialize two pointers, `slowPtr` and `fastPtr`, to the second node in the linked list.
2. Move `slowPtr` one node at a time and `fastPtr` two nodes at a time until they meet. This indicates that the linked list has a loop.
3. Reset `fastPtr` to the head of the linked list and move both pointers one node at a time until they meet again. This time, they will meet at the beginning of the loop.

[Implementation]
Here's how you can implement this class:

```python
class LinkedList:
    def __init__(self, value):
        self.value = value
        self.next = None

    def find_loop(self):
        # Initialize two pointers to the second node
        slow_ptr = self.next
        fast_ptr = self.next.next

        # Move the pointers until they meet
        while slow_ptr != fast_ptr:
            slow_ptr = slow_ptr.next
            fast_ptr = fast_ptr.next.next

        # Reset fast_ptr to the head and move both pointers one node at a time
        fast_ptr = self
        while fast_ptr != slow_ptr:
            slow_ptr = slow_ptr.next
            fast_ptr = fast_ptr.next

        # Return the node at which the pointers meet
        return fast_ptr
```

[Explanation]
This class `LinkedList` implements the two-pointer technique to detect and return the node at the beginning of a loop in a linked list. The `find_loop` method moves the pointers until they meet, then resets the fast pointer to the head and moves both pointers one node at a time until they meet again. This time, they will meet at the beginning of the loop.

[Tests]
To test this class, you can use the following code:

```python
# Create a linked list with a loop
head = LinkedList(1)
head.next = LinkedList(2)
head.next.next = LinkedList(3)
head.next.next.next = LinkedList(4)
head.next.next.next.next = LinkedList(5)
head.next.next.next.next.next = head.next.next

# Test that the loop is correctly detected
assert head.find_loop() == head.next.next
```

### Example 21
[Code]
import os
import sysconfig
import sys

def distutils_dir_name(dname):
    """Returns the name of a distutils build directory"""
    f = "{dirname}.{platform}-{version[0]}.{version[1]}"
    return f.format(dirname=dname,
                    platform=sysconfig.get_platform(),
                    version=sys.version_info)


print(os.path.join('build', distutils_dir_name('lib')), end = '')

[Property]
category: code generation (function implementation)
language: Python
concepts: cross-platform compatibility, build directory naming, string formatting

[Instruction]
Write a Python function that returns the name of a distutils build directory based on the current platform and Python version. The function should take a string `dname` as input and return a string in the format `dname.platform-version[0].version[1]`, where `platform` is the current platform, and `version[0]` and `version[1]` are the major and minor versions of the current Python interpreter, respectively. The function should also handle cross-platform compatibility.

[Response]
[Reasoning]
To generate the name of a distutils build directory, we can follow these steps: 

1. Get the current platform: We can use the `sysconfig` module's `get_platform` function to get the current platform in a format that is compatible with distutils build directories.
2. Get the current Python version: We can use the `sys` module's `version_info` attribute to get the current Python version as a tuple of integers.
3. Format the string: We can use string formatting to insert the platform and version information into the desired format.

[Implementation]
Here's how you can implement this function:

```python
import sys
import sysconfig

def get_distutils_build_dir(dname: str) -> str:
    # Get the current platform
    platform = sysconfig.get_platform()
    # Get the current Python version
    version = sys.version_info
    # Format the string
    return f"{dname}.{platform}-{version[0]}.{version[1]}"
```

[Explanation]
This function uses the `sysconfig` and `sys` modules to get the current platform and Python version, respectively. It then uses string formatting to insert this information into the desired format.

[Tests]
You can test this function with a few different inputs to ensure it works correctly:

```python
assert get_distutils_build_dir('lib') == 'lib.' + sysconfig.get_platform() + '-' + str(sys.version_info[0]) + '.' + str(sys.version_info[1])
assert get_distutils_build_dir('bin') == 'bin.' + sysconfig.get_platform() + '-' + str(sys.version_info[0]) + '.' + str(sys.version_info[1])
assert get_distutils_build_dir('include') == 'include.' + sysconfig.get_platform() + '-' + str(sys.version_info[0]) + '.' + str(sys.version_info[1])
```

### Example 22
[Code]
def get_hashes(buf):
    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')
    if isinstance(buf, str):
        buf = open(buf, 'rb').read()
    md5 = hashlib.md5(buf).hexdigest()
    sha1 = hashlib.sha1(buf).hexdigest()
    sha256 = hashlib.sha256(buf).hexdigest()
    sha512 = hashlib.sha512(buf).hexdigest()
    ctph = ssdeep.hash(buf)
    return hexdigests._make((md5, sha1, sha256, sha512, ctph))

[Property]
category: code generation (function implementation)
language: Python
concepts: hash computation, file input handling, namedtuple, string formatting

[Instruction]
Write a Python function that takes a file path or a binary string as input and returns a `namedtuple` containing the MD5, SHA1, SHA256, and SHA512 hashes of the input. The function should handle both file paths and binary strings as input and return the hashes as hexadecimal strings.

[Response]
[Reasoning]
To compute the hashes of a file or a binary string, we'll follow these steps:

1. If the input is a string, convert it to a binary string by opening the file in binary mode and reading its contents.
2. Compute the MD5, SHA1, SHA256, and SHA512 hashes using the `hashlib` module.
3. Return the hashes as a `namedtuple` for easy access and string formatting.

[Implementation]
Here's how you can implement this function:

```python
import hashlib
from collections import namedtuple

def get_hashes(buf):
    # Create a namedtuple to store the hashes
    Hashes = namedtuple('Digests', 'md5 sha1 sha256 sha512')

    # If the input is a string, convert it to a binary string
    if isinstance(buf, str):
        buf = open(buf, 'rb').read()

    # Compute the hashes
    md5 = hashlib.md5(buf).hexdigest()
    sha1 = hashlib.sha1(buf).hexdigest()
    sha256 = hashlib.sha256(buf).hexdigest()
    sha512 = hashlib.sha512(buf).hexdigest()

    # Return the hashes as a namedtuple
    return Hashes(md5, sha1, sha256, sha512)
```

[Explanation]
This function uses the `hashlib` module to compute the MD5, SHA1, SHA256, and SHA512 hashes of the input. It also uses the `ssdeep` module to compute the CTPH hash. The `namedtuple` is used to store the hashes for easy access and string formatting.

[Tests]
You can test this function with a few test cases:

```python
import hashlib

string = 'test.txt'
binary = string.encode()
# Test with a file path
assert get_hashes(binary).md5 == hashlib.md5(binary).hexdigest()
assert get_hashes(binary).sha1 == hashlib.sha1(binary).hexdigest()
assert get_hashes(binary).sha256 == hashlib.sha256(binary).hexdigest()
assert get_hashes(binary).sha512 == hashlib.sha512(binary).hexdigest()
```

### Example 23
[Code]
class Solution:
    def isIdealPermutation(self, A):
        """
        :type A: List[int]
        :rtype: bool
        """        
        size, m = len(A), 0
        for i in range(size - 2):
            m = max(m, A[i])
            if m > A[i + 2]:
                return False
        return True

[Property]
category: code generation (class implementation)
language: Python
concepts: local maxima, global maxima, array traversal, greedy algorithm

[Instruction]
Write a Python class with a method `isIdealPermutation(A)` that takes in an array `A` of integers and returns `True` if the number of local maxima in `A` is equal to the number of global maxima in `A`. A local maximum is an element in the array that is greater than both its adjacent elements. A global maximum is an element in the array that is greater than all elements to its right. Use a greedy algorithm to traverse the array and keep track of the local and global maxima.

[Response]
[Reasoning]
To implement the required class and method, we can follow these steps:

1. Initialization of the Maximum Variable: Before the loop starts, `mx` is initialized to 0. This variable is used to keep track of the maximum value encountered in the array up to two positions before the current index.
2. Loop through the Array: The `for` loop iterates from the third element (index 2) to the end of the array `A`. This allows the comparison of each element with the maximum value of the elements up to two positions before it.
3. Update Maximum and Check Condition: Inside the loop, `mx` is updated to be the maximum of the current `mx` and the element at position `i-2` of the array. This assignment uses the walrus operator `:=`, which assigns a value to `mx` and simultaneously checks if `mx` is greater than `A[i]`.
4. Return Value Based on Condition: If at any point during the iteration `mx` (the maximum value found up to two positions before the current index) is greater than the current element `A[i]`, the method immediately returns False, indicating that there is a non-local inversion in the array. If the loop completes without finding any such case, the method returns True, indicating all inversions in the array are local.

[Implementation]
Here's how you can implement this class and method:

```python
class Solution:
    def isIdealPermutation(self, A) -> bool:
        mx = 0
        for i in range(2, len(A)):
            if (mx := max(mx, A[i - 2])) > A[i]:
                return False
        return True
```

[Explanation]
This class `Solution` implements the method `isIdealPermutation` that traverses the array `A` and keeps track of the number of local and global maxima. It then compares these two values and returns `True` if they are equal, indicating that the number of local maxima is equal to the number of global maxima.

[Tests]
To verify the correctness of this class and method, we can run the following tests:

```python
assert Solution().isIdealPermutation([1, 0, 2]) == True
assert Solution().isIdealPermutation([1, 2, 0]) == False
```

### Example 24
[Code]
from collections import Counter

class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        return sum(k for k, v in Counter(nums).items() if v == 1)

[Property]
category: code generation (function implementation)
language: Python
concepts: dictionary-based counting, filtering unique elements with list comprehension, summation of elements based on condition

[Instruction]
Write a Python function that takes a list from user input and prints the sum of counts for elements that occur more than once. Use a dictionary to count frequencies efficiently. Utilize a list comprehension to extract repeated elements based on the frequency counts, and sum their corresponding counts from the dictionary.

[Response]
[Reasoning]
To implement this function, we first need to parse the user input as a list of integers and then count the frequency of each element using a dictionary. We can then calculate the sum of the counts for elements that occur more than once.

[Implementation]
Here's a sample Python function that accomplishes this:

```python
def sum_repeated_counts():
    nums = list(map(int, input().split()))
    freq_dict = {}
    for num in nums:
        freq_dict[num] = freq_dict.get(num, 0) + 1
    sum_of_repeats = sum(v for k, v in freq_dict.items() if v > 1)
    print(sum_of_repeats)
```

[Explanation]
This function reads a list of integers from the user input, counts the frequency of each element using a dictionary, and then calculates the sum of counts for elements that occur only once.

[Tests]
We can test this program with I/O redirection to simulate user input and output. Here is an example:

```python
test_cases = [
    ("1 2 2 3 3 3\n", "5\n"),
    ("1 1 1 1 1\n", "5\n"),
    ("1 2 3 4 5\n", "0\n"),
    ("\n", "0\n")
]

for input_data, expected_output in test_cases:
    stdin, stdout = sys.stdin, sys.stdout
    sys.stdin = StringIO(input_data)
    sys.stdout = StringIO()
    sum_repeated_counts()
    output = sys.stdout.getvalue()
    assert output == expected_output
```

### Example 25

[Code]
fp=open('cmd.sh','r')
lines=fp.readlines()
for i,line in enumerate(lines):
    cmd=line.replace('\n','')
    print i,cmd
    p=os.popen(cmd)
    x=p.read()
    p.close()
fp.close

[Property]
category: code generation (program implementation)
language: Python
concepts: iterating over file lines, command execution from file input, new line character removal

[Instruction]
Develop a Python program that reads a text file containing one shell command per line and executes these commands sequentially. Each command should be sanitized by removing unnecessary newline characters before execution. Provide clear error handling and logging to manage exceptions that might occur during the execution of the commands.

[Response]
[Reasoning]
To create a Python program that reads and executes shell commands from a text file, we can use Python’s built-in module `subprocess` for running the commands and `logging` for handling logs and errors. The program will involve reading and sanitizing the commands from a file, executing them sequentially, and logging the results or errors.

[Implementation]
Below is the Python script that demonstrates the described functionality:

```python
import subprocess
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s:%(levelname)s:%(message)s')

def read_commands(file_path):
    """Reads a text file and returns a list of commands."""
    try:
        with open(file_path, 'r') as file:
            commands = file.readlines()
        commands = [cmd.strip() for cmd in commands]  # Remove newline characters and spaces
        return commands
    except FileNotFoundError:
        logging.error(f"The file {file_path} was not found.")
        raise
    except Exception as e:
        logging.error(f"An error occurred while reading the file: {str(e)}")
        raise

def execute_command(command):
    """Executes a single shell command."""
    try:
        logging.info(f"Executing command: {command}")
        result = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        logging.info(f"Command output: {result.stdout.decode().strip()}")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error executing command '{command}': {e.stderr.decode()}")
    except Exception as e:
        logging.error(f"An unexpected error occurred: {str(e)}")

def main(file_path):
    """Main function to read commands from a file and execute them."""
    commands = read_commands(file_path)
    for command in commands:
        execute_command(command)
```

[Explanation]
In this script, we configure logging to track the execution status and errors. `read_commands` reads the commands from a specified file and strips unnecessary whitespace and newlines using `strip()`. `execute_command` runs a given shell command using `subprocess.run` and handles errors, logging the output or error messages. The `main` function reads and executes the commands sequentially, logging any exceptions that occur during the process.

[Tests]
To test this program, we can use Python's `unittest` framework along with `mock_open` to simulate file operations, `patch` to mock `subprocess.run` for testing command execution, and `assertLogs` to verify the logging output. Here's an example of how you can write tests for this program:

```python
import unittest
from unittest.mock import mock_open, patch, MagicMock

class TestCommandExecutor(unittest.TestCase):
    def test_read_commands_success(self):
        m = mock_open(read_data="ls\npwd\n")
        with patch('builtins.open', m):
            result = read_commands("dummy_path")
            self.assertEqual(result, ['ls', 'pwd'])

    def test_read_commands_file_not_found(self):
        with patch('builtins.open', mock_open()) as mocked_file:
            mocked_file.side_effect = FileNotFoundError
            with self.assertRaises(FileNotFoundError):
                read_commands("nonexistent_path")

    @patch('subprocess.run')
    def test_execute_command_success(self, mock_run):
        mock_run.return_value = MagicMock(stdout=b"Execution successful", stderr=b"")
        execute_command("ls")
        mock_run.assert_called_once_with("ls", shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    @patch('subprocess.run')
    def test_execute_command_failure(self, mock_run):
        error_message = b"Command failed"
        mock_run.side_effect = subprocess.CalledProcessError(1, 'ls', stderr=error_message)
        with self.assertLogs(level='ERROR') as log:
            execute_command("ls")
            self.assertIn("Error executing command 'ls'", log.output[0])
            self.assertIn("Command failed", log.output[0])

if __name__ == "__main__":
    unittest.main()
```

### Example 26
[Code]
def busca_linear_recursiva(array,elemento):
    i = -1
    return busca_recursiva(array,elemento, i)

def busca_recursiva(array,elemento, i):
    i += 1
    if(i == len(array)):
       return -1
    if(array[i] == elemento):
        return i
    return busca_recursiva(array,elemento,i)

[Property]
category: code generation (program implementation)
language: Python
concepts: linear search with recursion, default parameter initialization, multiple base cases in recursion

[Instruction]
Design a Python program that not only searches for a target value in a list using recursion but also constructs a trace of the indices it checks. This program should return both the index of the target, if found, or `-1` if not, alongside a list of the indices it examined during the search. The function should handle cases where the target is not present in the list.

[Response]
[Reasoning]
We can implement a recursive linear search function that returns the index of the target element if found or `-1` if not. To keep track of the indices examined during the search, we can pass a list as an additional parameter to store these indices. The function will incrementally add the indices to this list as it traverses the array.

[Implementation]
Here is the Python program that implements this functionality:

```python
def search_recursive(arr, target, index, indices_checked):
    """Recursive function to search for the target value in the list."""
    if index >= len(arr):
        return -1
    indices_checked.append(index)
    if arr[index] == target:
        return index
    return search_recursive(arr, target, index + 1, indices_checked)

def recursive_search(arr, target):
    """Wrapper function to initiate recursive search."""
    indices_checked = []
    result = search_recursive(arr, target, 0, indices_checked)
    return result, indices_checked

# Example usage
if __name__ == "__main__":
    array = [2, 3, 4, 8, 5, 9, 1, 6, 5, 7, 5]
    target = 6
    result, indices = recursive_search(array, target)
    print(f"Target {target} found at index {result} with indices checked: {indices}")
```

[Explanation]
In this program, the `search_recursive` function recursively searches for the target element in the list and appends the indices checked to the `indices_checked` list. The `recursive_search` function acts as a wrapper to initiate the recursive search and return the result along with the list of indices checked.

[Tests]
To test the implementation, we need to ensure that both the index of the target element and the list of indices checked are correct. Here are the test cases:

```python
# Test case 1: Target found in the list
arr1 = [2, 3, 4, 8, 5, 9, 1, 6, 5, 7, 5]
target1 = 6
expected_result1 = arr1.index(target1)
expected_indices1 = list(range(expected_result1 + 1))
result1, indices_checked1 = recursive_search(arr1, target1)
assert result1 == expected_result1
assert indices_checked1 == expected_indices1

# Test case 2: Target not found in the list
arr2 = [1, 2, 3, 4, 5]
target2 = 6
expected_result2 = -1
expected_indices2 = list(range(len(arr2)))
result2, indices_checked2 = recursive_search(arr2, target2)
assert result2 == expected_result2
assert indices_checked2 == expected_indices2

# Test case 3: Target found at the end of the list
arr3 = [5, 4, 3, 2, 1]
target3 = 1
expected_result3 = len(arr3) - 1
expected_indices3 = list(range(expected_result3 + 1))
result3, indices_checked3 = recursive_search(arr3, target3)
assert result3 == expected_result3
assert indices_checked3 == expected_indices3
```

### Example 27
[Code]
Data = np.zeros([break_points[-1],size_blocks])
Data_stacked = np.zeros([break_points[-1]-num_blocks+1, size_blocks*num_blocks])
cluster_point_list = []
for counter in xrange(len(break_points)):
        break_pt = break_points[counter]
        cluster = seg_ids[counter]
        if counter == 0:
                old_break_pt = 0
        else:
                old_break_pt = break_points[counter-1]
        for num in xrange(old_break_pt,break_pt):
                ##generate the point from this cluster
                # print "num is:", num
                if num == 0:

[Property]
category: code generation (program implementation)
language: Python
concepts: NumPy array initialization, iteration over break points, cluster segmentation, nested loops

[Instruction]
Implement a Python program that initializes a NumPy array randomly (0--1) and segments it into clusters based on provided breakpoints. Each cluster is defined by consecutive elements between two breakpoints. The output should be a list of NumPy arrays representing these clusters.

For example, given a size 10 and breakpoints `[3, 6, 8]`, the program should first initialize a NumPy array of 10 random elements between 0 and 1 and then output three clusters: elements at indices `0-2`, `3-5`, `6-7`, and `8-9`. Ensure that the program handles cases where breakpoints are at the boundaries of the array or if there are no breakpoints, in which case the entire array should be a single cluster. Include error handling to manage invalid inputs such as negative array sizes or breakpoints that are out of range.

[Response]
[Reasoning]
We can implement this Python program in Numpy following these steps:

1. Initialize a random NumPy array (0--1) of the specified size.
2. Iterate over the provided breakpoints to segment the array into clusters.
3. For each cluster, extract the elements between the current and previous breakpoints.

[Implementation]
Here is an example implementation of the program:

```python
import numpy as np

def segment_array(data, break_points):
    break_points = [0] + break_points + [len(data)]
    segmented_arrays = []
    for i in range(len(break_points) - 1):
        start_index = break_points[i]
        end_index = break_points[i + 1]
        segmented_arrays.append(data[start_index:end_index])
    return segmented_arrays

def create_clusters(size, break_points):
    if size <= 0:
        raise ValueError("Array size must be positive.")
    data = np.random.rand(size)
    clusters = segment_array(data, break_points)
    return clusters

# Example usage
if __name__ == "__main__":
    size = 10
    break_points = [3, 6, 8]
    clusters = create_clusters(size, break_points)
    for i, cluster in enumerate(clusters):
        print(f"Cluster {i}: {cluster}")
```

[Explanation]
In this implementation, `segment_array` transforms the input data array into a list of NumPy arrays based on the provided breakpoints. The `main` function initializes a random NumPy array of a specified size and calls `segment_array` to segment the array into clusters based on the breakpoints.

[Tests]
To test the program, we can verify that the values in each cluster are within the expected range (0--1) and that the clusters are correctly segmented. Here are some test cases:

```python
def test_segmentation(size, break_points):
    clusters = create_clusters(size, break_points)
    for cluster in clusters:
        assert np.all(cluster >= 0) and np.all(cluster <= 1)
    break_points = [0] + break_points + [size]
    for i in range(len(break_points) - 1):
        assert len(clusters[i]) == break_points[i + 1] - break_points[i]

# Test cases
test_cases = [
    (20, [5, 10, 15]),
    (10, [3, 6, 8]),
    (15, [3, 6, 12]),
    (30, [7, 14, 21, 27]),
    (5, [1]),
    (10, []),
    (50, [10, 20, 30, 40]),
]

for size, breakpoints in test_cases:
    test_segmentation(size, breakpoints)
```

### Example 28
[Code]
if match_case == 'auto':
    if len(set([ch_name.lower() for ch_name in ch_names])) < len(set(ch_names)):
        match_case = True
    else:
        match_case = False

if match_case:
    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)
else:
    ch_names = [ch_name.lower() for ch_name in ch_names]
    pick_chs = [pick_ch.lower() for pick_ch in pick_chs]
    picks = mne.pick_channels(ch_names, pick_chs, ordered=ordered)

return picks

[Property]
category: code generation (function implementation)
language: Python
concepts: case-insensitive string matching, controlled case matching based on an option, list comprehension

[Instruction]
Construct a Python program that processes a list of strings provided by the user. The first element is a target string, the second is either 'CaseSensitive' or 'CaseInsensitive' to determine the matching approach, and the remaining elements are candidates for comparison. The program should output the number of times the target appears among the candidates according to the specified matching rule. The solution should include robust error handling to validate the matching rule and check that at least two strings are provided before proceeding.

For example, given the input `['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']`, the program should output `2` since 'Apple' and 'APPLE' match the target 'apple' in a case-insensitive manner.

[Response]
[Reasoning]
You can implement the program by first parsing the input list, with proper validation to ensure that it contains the target string and the matching rule. Based on the matching rule, you can compare the target string with the candidate strings either in a case-sensitive or case-insensitive manner. Finally, you can print the count of matches.

[Implementation]
Here is an example implementation of the program:

```python
def count_matches(input_list):
    if not input_list or len(input_list) < 2:
        raise ValueError("Input list must contain at least two items: the target string and the matching rule.")
    
    target_string, matching_rule = input_list[0], input_list[1]
    if matching_rule not in ['CaseSensitive', 'CaseInsensitive']:
        raise ValueError("Matching rule must be either 'CaseSensitive' or 'CaseInsensitive'.")

    candidates = input_list[2:]
    if matching_rule == 'CaseSensitive':
        match_count = sum(1 for candidate in candidates if candidate == target_string)
    else:
        target_string = target_string.lower()
        match_count = sum(1 for candidate in candidates if candidate.lower() == target_string)

    return match_count

def main():
    input_list = input().split()
    print(count_matches(input_list))

if __name__ == "__main__":
    main()
```

[Explanation]
The `count_matches` function implements the main logic of the program, counting the occurrences of the target string among the candidate strings based on the specified matching rule. The `main` function reads the input list from the user, calls `count_matches`, and prints the count of matches.

[Tests]
You can test the program with various inputs to ensure it handles different scenarios correctly:

```python
assert count_matches(['apple', 'CaseInsensitive', 'Apple', 'banana', 'APPLE']) == 2
assert count_matches(['apple', 'CaseSensitive', 'Apple', 'banana', 'APPLE']) == 0
assert count_matches(['apple', 'CaseInsensitive']) == 0
assert count_matches(['apple', 'CaseInsensitive', 'apple', 'APPLE', 'aPpLe', 'banana']) == 3
assert count_matches(['apple', 'CaseSensitive', 'apple', 'APPLE', 'aPpLe', 'banana']) == 1

try:
    count_matches(['apple'])
    assert False
except ValueError as e:
    assert str(e) == "Input list must contain at least two items: the target string and the matching rule."

try:
    count_matches(['apple', 'InvalidRule', 'Apple'])
    assert False
except ValueError as e:
    assert str(e) == "Matching rule must be either 'CaseSensitive' or 'CaseInsensitive'."
```