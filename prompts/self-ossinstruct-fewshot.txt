### System: I->R
Provide the best response to a given instruction. Follow the following steps to craft your response:
1. reason about the given instruction
2. provide a high-quality solution
3. offer a concise explanation
4. write assertions and **invoke them** to verify the correctness your solution

### System: C->I
Create a set of independent code instructions that are original, different, diverse, and high-quality, where the properties control an instruction's category, language, concepts, and difficulty.

### System: S->C
Extract key programming concepts from a given code snippet collected from the open source repositories. Present the concepts as a comma separated list.

### Example 1
[Code]
    value = int(round((value - prev) * 1e5))
    value = ~(value << 1) if value < 0 else (value << 1)
    chunks = _split_into_chunks(value)
    return (chr(chunk + 63) for chunk in chunks)
def _split_into_chunks(value):
    while value >= 32:  # 2^5, while there are at least 5 bits
        # first & with 2^5-1, zeros out all the bits other than the first five
        # then OR with 0x20 if another bit chunk follows
        yield (value & 31) | 0x20
        value >>= 5

[Property]
category: code generation (function implementation)
language: Python
concepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling

[Instruction]
Create a Python function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.

[Response]
[Reasoning]
To encode an integer into a sequence of encoded characters based on the specified criteria, let's follow these steps:

1. Break down the integer into 5-bit chunks: Extract 5-bit chunks from the integer using using `& 31` (`0x1F`), because the binary representation of `31` (`11111`) has the last five bits set, which will effectively extract the 5 bits we are interested in. We start from the least significant bits (LSB).
2. Set continuation bit: For all chunks except the last one, set the 6th bit to 1 using `| 32` (`0x20`) because the binary representation of `32` (`100000`) has the 6th bit set to 1. This indicates that there's another continuation chunk following.
3. Shift right: Right-shift the value by 5 to process the next 5 bits.
4. Convert to characters: Use `ord` and `chr` to convert each chunk (now effectively 6 bits due to the continuation bit) into a character by adding 63 to its value. This ensures that the character is within a printable ASCII range.
5. Assembly: Assemble these characters into the final encoded string while maintaining the order of the chunks through `reversed`.

[Implementation]
Here's how you can implement this function:

```python
def encode_integer_to_chars(value: int) -> str:
    # Base case for 0
    if value == 0:
        return chr(63)

    encoded_chars = []
    while value > 0:
        # Extract the 5-bit chunk and add 63 to its value
        chunk = (value & 31) + 63
        value >>= 5
        # If there's still more of the value left, set the continuation bit
        if value > 0:
            chunk |= 32
        encoded_chars.append(chr(chunk))

    # Reverse the list of characters to start with the least significant chunk
    # and join them into a single string
    return ''.join(reversed(encoded_chars))
```

[Explanation]
This function processes the integer bit by bit in 5-bit chunks, applying bitwise operations to extract and manipulate these chunks, then converts each chunk into a character using the specified encoding scheme. This approach efficiently handles the encoding in a loop until all bits of the integer have been processed.

Note that this function is designed for non-negative integers and does not support negative integers by default because negative numbers are represented in two's complement form, where the most significant bit (MSB) indicates the sign. In Python, right-shifting (`>>`) a negative integer preserves the sign bit, effectively making the never executed due to the `value > 0` condition. If you change it to `value != 0`, it will then lead to an infinite loop if the same encoding logic is applied to negative integers without modifications.

[Tests]
You can validate this function with a few test cases to ensure correctness:

```python
assert encode_integer_to_chars(0) == chr(63)
assert encode_integer_to_chars(1) == chr(63 + 1)
assert encode_integer_to_chars(31) == chr(63 + 31)
assert encode_integer_to_chars(int(0b1)) == chr(0b1 + 63)
assert encode_integer_to_chars(int(0b1000001)) == chr(0b10 + 63) + chr(63 + 0b100001)
```

These tests cover scenarios from zero to a number requiring more than one chunk, ensuring the function operates as expected.

### Example 2
[Code]
def ceil_shift(n, b):
    """Return ceil(n / 2**b) without performing any floating-point or division operations.
    This is done by right-shifting n by b bits and incrementing the result by 1
    if any '1' bits were shifted out.
    """
    if not isinstance(n, int) or not isinstance(b, int):
        raise TypeError("unsupported operand type(s): %r and %r" % (type(n).__name__, type(b).__name__))
    assert n >= 0 and b >= 0    # I haven't tested or even thought about negative values
    mask = (1 << b) - 1
    if n & mask:
        return (n >> b) + 1
    else:

[Property]
category: code generation (function implementation)
language: Python
concepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks

[Instruction]
Develop a Python function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.

[Response]
[Reasoning]
We can leverage the properties of bitwise operations to develop a Python function that computes the ceiling of `n / 2**b` without using division, floating-point operations, or any built-in functions like `math.ceil`, and strictly avoiding converting the problem into a floor computation.

In the context, dividing by `2**b` is equivalent to right-shifting `n` by `b` bits in binary representation when `n` is divisible by `2**b`. Otherwise, this approach inherently computes the floor of the division. To adjust for the ceiling without directly calculating it, we can consider two cases:

1. If `n` is divisible by `2**b`, the result of the division is simply the value of right-shifting `n` by `b` bits.
2. Otherwise, we need to increment the right-shifted result by 1 to achieve the ceiling effect.

To determine the divisibility of `n` by `2**b`, we can check if the first `b` bits of `n` are all 0. This can be done using a mask with the first `b` bits set to 1, and then performing a bitwise AND operation with `n`. If the result is 0, it indicates that `n` is divisible by `2**b`. The mask can be created using `mask = (1 << b) - 1`.

We'll also include assertions to ensure that `n` and `b` are non-negative integers.

[Implementation]
Here is the implementation of `ceil_divide_without_div`:

```python
def ceil_divide_without_div(n: int, b: int) -> int:
    assert isinstance(n, int) and n >= 0, "n must be a non-negative integer"
    assert isinstance(b, int) and b >= 0, "b must be a non-negative integer"

    # Constructing the mask to check divisibility
    mask = (1 << b) - 1
    divisible = (n & mask) == 0

    result = n >> b

    # If n is not divisible by 2**b, increment the result to get the ceiling
    if not divisible:
        result += 1

    return result
```

[Explanation]
This function calculates the ceiling of `n / 2**b` purely through bitwise manipulation and integer arithmetic. The assertions ensure the input constraints are met, as specified.

[Tests]
To verify the correctness of the function, we can run the following tests:

```python
import math

assert ceil_divide_without_div(10, 3) == math.ceil(10 / 2**3)
assert ceil_divide_without_div(17, 4) == math.ceil(17 / 2**4)
assert ceil_divide_without_div(100, 5) == math.ceil(100 / 2**5)
assert ceil_divide_without_div(0, 3) == math.ceil(0 / 2**3)
assert ceil_divide_without_div(1, 0) == math.ceil(1 / 2**0)
```

These tests compare the results of our function with the expected results obtained using `math.ceil` to ensure the correctness of the ceiling division operation.

### Example 3
[Code]
    isprime = n >= 2 and 1 or 0
    for prime in prime_list:                    # Check for factors with all primes
        if prime * prime > n: break             # ... up to sqrt(n)
        if not n % prime:
            isprime = 0
            break
    if isprime: prime_dict[n] = 1               # Maintain a dictionary for fast lookup
    return isprime
def prime(x):
    ''' Returns the xth prime '''
    lastn = prime_list[-1]
    while len(prime_list) <= x:                 # Keep working until we've got the xth prime
        lastn = lastn + 1                       # Check the next number

[Property]
category: code generation (class implementation)
language: Python
concepts: prime number memoization, n-th prime calculation, efficiency in prime checks

[Instruction]
Implement a Python class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.

[Response]
[Reasoning]
Implementing the required Python class with the method `find_nth_prime_memoized(n)` involves several key steps:

1. The class should have a constructor `__init__` that initializes the cache list to store the memoized prime numbers. Initially, the list can be seeded with the first two prime numbers, 2 and 3.
2. The method `find_nth_prime_memoized` will check if the requested `n`th prime is already in the memoized list. If it is, it will return that prime directly. If not, it will start from the last cached prime and continue to find and cache new primes until the `n`th prime is found.
3. A helper method `is_prime` can be defined to check if a number is prime. To efficiently check for primality:
    - It checks if the number is divisible by each of the primes already in the cache.
    - It only checks up to the square root of the number to be tested, implemented by comparing the square of the prime with the number.
    - It skips even numbers by incrementing by 2 for each prime check. This is sound since the cache is initialized with the first **two** primes, 2 and 3.

[Implementation]
Here is how you could implement such a class:

```python
class PrimeFinder:
    def __init__(self):
        self.primes = [2, 3]

    def is_prime(self, num: int) -> bool:
        if num < 2:
            return False
        for prime in self.primes:
            if prime * prime > num:
                break
            if num % prime == 0:
                return False
        return True

    def find_nth_prime_memoized(self, n: int) -> int:
        # Return the n-th prime directly if already in cache
        if n <= len(self.primes):
            return self.primes[n - 1]

        # Start checking from the number after the last prime in cache
        current_num = self.primes[-1] + 2
        while len(self.primes) < n:
            if self.is_prime(current_num):
                # Cache the new prime
                self.primes.append(current_num)
            # Skip even numbers
            current_num += 2

        return self.primes[n - 1]
```

[Explanation]
This class `PrimeFinder` initializes with a cache of the first two primes. The `is_prime` method checks if a number is prime by dividing it with cached primes up to its square root. The `find_nth_prime_memoized` method uses this helper method to find and cache primes up to the requested `n`th one. Subsequent calls leverage cached primes for efficiency.

[Tests]
Here's how you can test this class:

```python
# Test that the class correctly finds the first few primes
first_few_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
prime_finder = PrimeFinder()
for i, prime in enumerate(first_few_primes, 1):
    assert prime_finder.find_nth_prime_memoized(i) == prime

# Test that the memoized results are returned directly
for i, prime in enumerate(first_few_primes, 1):
    assert prime_finder.find_nth_prime_memoized(i) == prime
```

These tests verify that the class correctly finds the first few primes and that subsequent calls return the memoized results directly.

### Example 4
[Code]
    return (a + 1) * (b + 1) - 1
def keys_count(a, b):
    return powerset(a, b) * 2 - a - b
def formula(k):
    if k % 2 != 0:
        return ((k + 1) ** 2) / 2 + k + 1
    else:
        return (k ** 2) / 2 + 2 * k + 1
def multiset_powerset(multiset):
    n = len(multiset)
    c = [0] * n
    while True:
        changed = False
        i = n - 1
        while i >= 0 and not changed:

[Property]
category: code generation (function implementation)
language: Python
concepts: special formula implementation, odd and even number handling, function composition

[Instruction]
Here are two special formulas:

$$
f_1(a, b) = (a + 1) \cdot (b + 1) - 1
$$

$$
f_2(k) = \begin{cases}
    \frac{(k + 1)^2}{2} + k + 1 & \text{if } k \text{ is odd} \\
    \frac{k^2}{2} + 2k + 1 & \text{if } k \text{ is even}
\end{cases}
$$

Write a Python function to return $f_2(f_1(a, b))$ for given `a` and `b`.

[Response]
[Reasoning]
Based on the formulas you provided, we can define two Python functions, `f1(a, b)` and `f2(k)`, respectively, and then combine them to calculate $f2(f1(a, b))$ for given `a` and `b`.

[Implementation]
Here is the implementation:

```python
def f1(a, b):
    return (a + 1) * (b + 1) - 1

def f2(k):
    if k % 2 == 0:  # Check if k is even
        return (k**2) / 2 + 2 * k + 1
    else:  # k is odd
        return ((k + 1)**2) / 2 + k + 1

def f1_f2_combined(a, b):
    return f2(f1(a, b))
```

[Explanation]
In this implementation:
- `f1(a, b)` calculates the first formula you've given.
- `f2(k)` calculates the second formula, with a conditional branch for whether `k` is even or odd.
- `f1_f2_combined(a, b)` uses the output of `f1(a, b)` as the input for `f2(k)` and returns the result.

[Tests]
To test this combined function, you can simply compare it with the direct application of `f2` to the result of `f1` for different values of `a` and `b`:

```python
assert f1_f2_combined(2, 3) == f2(f1(2, 3))
assert f1_f2_combined(4, 5) == f2(f1(4, 5))
assert f1_f2_combined(6, 7) == f2(f1(6, 7))
```

### Example 5
[Code]
    while left<len(arr) and ryt >= start and left <= ryt:
        mid = (left+ryt)//2
        if arr[mid] == target:
            return mid
        elif arr[mid] > target:
            ryt = mid-1
        else:
            left = mid+1
    return left
def tripletsSorting(nums, t):
    # TimeComplexity = O((n^2)logn)
    nums.sort()
    count = 0
    for i in range(len(nums)):

[Property]
category: code generation (function implementation)
language: Python
concepts: insertion point for a sorted array, optimized time complexity

[Instruction]
Design a Python function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.

For example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.

[Response]
[Reasoning]
To solve this problem efficiently and ensure logarithmic time complexity, we can use a binary search algorithm. Compared with a standard binary search that looks for an exact match, we can modify the algorithm such that when the target is not found, we return the `left` bound, which represents the index where the target can be inserted to maintain the array's sorted order. Since any valid index for insertion is acceptable, we can direclty return the index if there is an exact match.

[Implementation]
Here is a Python function that implements this approach:

```python
from typing import List

def search_insert_position(nums: List[int], target: int) -> int:
    """
    Finds the index to insert `target` into `nums` to maintain sorted order. For example,
    given `nums = [1, 3, 5, 5, 6]` and `target = 5`, this function returns either 2 or 3,
    as `target` can be inserted at index 2 or 3 to maintain the sorted order.
    """
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2

        # Directly return the index if there's an exact match
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    # At this point, `left` is the correct insertion index
    return left
```

[Explanation]
This implementation ensures that when `target` is not found, `left` represents the correct insertion index. This is because at the end of the loop, all elements to the left of `left` are smaller than `target`, all elements to the right of `left` are equal to or larger than `target`, and `left > right`. Therefore, `left` is the correct index for insertion to maintain the sorted order.

[Tests]
To test this function, you can use the example you provided:

```python
# Provided example
assert search_insert_position([1, 3, 5, 5, 6], 5) in [2, 3]
# Additional cases
assert search_insert_position([1, 3, 5, 5, 6], 2) == 1
assert search_insert_position([1, 3, 5, 5, 6], 7) == 5
```

These tests cover the scenario where the target is found at multiple indices, as well as cases where the target is not present in the array but needs to be inserted at the correct position to maintain the sorted order.

### Example 6
[Code]
def decompress(self):
    source = self.compressed
    if isinstance(source, (bytes, bytearray)):
        return self.decompress_bytes()
    pos = 0
    node = self.root
    res = bytearray()

    while pos < len(source):
        code = int(source[pos])
        child = node.children[code]
        if child.is_leaf:
            res.append(child)
            node = self.root
        else:
            node = child
        pos += 1

    return bytes(res)

[Property]
category: code generation (class and function implementation)
language: Python
concepts: decoding Huffman compressed data, binary tree traversal, byte array processing

[Instruction]
Write a Python function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.

[Response]
[Reasoning]
To accomplish the Huffman decompression, we first need to define the `HuffmanNode` class, which, as required, should be a general tree structure with a `children` list and an optional `value` attribute to store the character associated with a leaf node.

Then, we'll implement the `huffman_decompress` function. This function will traverse the Huffman tree according to the bits in `compressed_data`. When it encounters a leaf node, the associated character will be appended to the result, and the traversal restarts from the root of the tree. This process continues until the entire `compressed_data` is processed.

You said that `compressed_data` is a byte array of 0/1 sequence, so I assume that each byte, not each bit, represents a step in the Huffman tree. In practice, it is more efficient

[Implementation]
Here's how we can implement this:

```python
class HuffmanNode:
    def __init__(self, value=None):
        self.value = value
        self.children = []

def huffman_decompress(compressed_data, huffman_tree):
    # Store the decompressed characters here
    result = []

    # Start traversal from the root of the Huffman tree
    node = huffman_tree

    # Each byte represents a 0/1 bit in `compressed_data`
    for bit in compressed_data:
        # Check if the node has children
        if len(node.children) > 0:
            node = node.children[int(bit)]
        # After moving to the child, check if it's a leaf node
        if len(node.children) == 0:
            result.append(node.value)
            # Reset to start from the root for the next character
            node = huffman_tree

    # Convert the result to bytes
    return "".join(result).encode()
```

[Explanation]
In this implementation, we assume that `compressed_data` is a byte array where each byte represents a 0/1 bit in the Huffman tree. We traverse the tree according to the bits in `compressed_data`, and when we reach a leaf node, we append the associated character to the result. Finally, we convert the result to `bytes` by concatenating the characters and encoding them.

[Tests]
You can test this function with a sample Huffman tree and compressed data to verify that the decompression works correctly:

```python
root = HuffmanNode()
root.children = [HuffmanNode('A'), HuffmanNode('B')]
root.children[0].children = [HuffmanNode('C'), HuffmanNode('D')]
root.children[1].children = [HuffmanNode('E'), HuffmanNode('F')]
compressed_data = bytearray([0, 1, 0, 0, 1, 1])
# 01 -> D, 00 -> C, 11 -> F
assert huffman_decompress(compressed_data, root) == b'DCF'
```

### Example 7
[Code]
def format_size(num):
    """http://stackoverflow.com/a/1094933
    """
    for x in ['bytes', 'KB', 'MB', 'GB']:
        if num < 1024.0 and num > -1024.0:
            return "%3.1f%s" % (num, x)
        num /= 1024.0
    return "%3.1f%s" % (num, 'TB')
assert format_size(1024**2 - 1) == '1024.0KB'
assert format_size(1024*512) == '512.0KB'

[Property]
category: code generation (function implementation)
language: Python
concepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation

[Instruction]
Create a Python function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: "{X.Y}{Unit}", where "Unit" is the appropriate size unit and "X.Y" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.

[Response]
[Reasoning]
To create such a function, we can use a loop to iterate through a predefined list of units (`['bytes', 'KB', 'MB', 'GB', 'TB']`) and check if the given number of bytes fits into the current unit by comparing it with 1024.0 and -1024.0 (for handling negative sizes). We'll keep dividing the number by 1024.0 until the correct unit is found where the number is less than 1024.0. Then, we'll format the result using the appropriate unit and the rounded size.

[Implementation]
```python
def format_size(size_bytes):
    units = ['bytes', 'KB', 'MB', 'GB', 'TB']
    if size_bytes == 0:
        return "0.0bytes"  # Directly return for 0 bytes to avoid division by zero in loop
    num = abs(size_bytes)
    unit = units[0]

    for u in units[1:]:
        if num < 1024.0:
            break
        num /= 1024.0
        unit = u

    formatted_size = f"{num:.1f}{unit}"
    return formatted_size if size_bytes >= 0 else f"-{formatted_size}"
```

[Explanation]
This implementation handles both positive and negative file sizes and returns the formatted size as a string, even though negative sizes are not common in real-world scenarios.

[Tests]
You can write the following test cases to ensure it works correctly:

```python
test_data = [
    (1024 ** 2, "1.0MB"),
    (1024 ** 2 - 1, "1024.0KB"),
    (1024 ** 3 * 512, "512.0GB"),
    (1024 ** 4 * 512, "512.0TB"),
]
for size, expected_output in test_data:
    assert format_size(size) == expected_output
    assert format_size(-size) == f"-{expected_output}"
```

These test cases cover both positive and negative sizes across different units to validate the correctness of the `format_size` function.

### Example 8
[Code]
def unify_stringlist(L: list):
    """ Adds asterisks to strings that appear multiple times, so the resulting
    list has only unique strings but still the same length, order, and meaning.
    For example:
        unify_stringlist(['a','a','b','a','c']) -> ['a','a*','b','a**','c']
    """
    assert(all([isinstance(l,str) for l in L]))
    return [L[i]+"*"*L[:i].count(L[i]) for i in range(len(L))]
assert unify_stringlist(list("abc")) == list("abc")

[Property]
category: code generation (function implementation)
language: Python
concepts: list comprehension, unique string creation, precondition checking for type validation

[Instruction]
Design a Python function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Make a precondition check through `assert` to ensure the input is a list of strings.

Solve the problem in two lines of code, one for the precondition check and the other for the main logic.

[Response]
[Reasoning]
You can achieve this functionality by first ensuring the input meets your requirements using an `assert` statement with list comprehension. Then, use another list comprehension to iterate through the input list and append `'*'` to the strings. The number of `'*'` is the number of occurrences of the string before the current index.

[Implementation]
Here's how you can do it in two lines of Python code:

```python
def encode_strings(input_list):
    assert all(isinstance(item, str) for item in input_list), "Input must be a list of strings"
    return [s + '*' * input_list[:i].count(s) for i, s in enumerate(input_list)]
```

[Explanation]
The `enumerate` function provides both the index and the string in each iteration, allowing you to count the occurrences of the string before the current index.

Note that although the function is concise, it is not the most efficient solution for large lists, as the `count` method has a time complexity of O(n) for each iteration. For larger lists, a more efficient approach might be to use a dictionary to store the counts of each string and then iterate through the list to append the appropriate number of `'*'` to each string.

[Tests]
Now you can test your function with the provided examples:

```python
assert encode_strings(['a', 'a', 'b', 'a', 'c']) == ['a', 'a*', 'b', 'a**', 'c']
assert encode_strings(['a', 'b', 'c']) == ['a', 'b', 'c']
```

### Example 9
[Code]
def _create_folds_list(data, count):
    """
    Creates folds from the given data.

    :param data: the data to fold
    :param count: the number of folds to create

    :return: a list of folds
    """

    fold_count = len(data) / count
    folds = list()

    for fold_index in range(count):
        low = int(fold_index * fold_count)
        high = int((fold_index + 1) * fold_count)

        fold = data[low:high]
        folds.append(fold)

    return folds

[Property]
category: code generation (function implementation)
language: Python
concepts: data partitioning and slicing, learning from input-output examples

[Instruction]
Construct a Python function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertion:

```python
assert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]
assert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]
assert create_folds(range(25), -5) == []
assert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]
```

[Response]
[Reasoning]
To create a Python function that generates a list of folds from given data with each fold having approximately equal length (with at most a difference of 1 between any two folds), you can follow these steps:

1. Return an empty list immediately if `count` is non-positive since it's not possible to create a valid number of folds.
2. Divide the total length of the data by `count`, rounding down, to get the minimum number of items each fold should have.
3. Calculate the remainder to see how many extra items need to be distributed among the folds. They are distributed one by one to the first `remainder` folds.
4. Use a loop to create each fold, adjusting the starting and ending indices based on the calculations above to ensure each fold has the correct number of items.

[Implementation]
Here's how you can implement this:

```python
def create_folds(data, count):
    # Return an empty list if count is non-positive
    if count <= 0:
        return []

    data_length = len(data)
    fold_size = data_length // count
    remainder = data_length % count

    folds = []
    start_index = 0

    for i in range(count):
        # Add 1 element to each of the first `remainder` folds
        end_index = start_index + fold_size + (1 if i < remainder else 0)
        folds.append(range(start_index, end_index))
        start_index = end_index

    return folds
```

[Explanation]
This implementation ensures that each fold has an equal length with at most a difference of 1 between any two folds. It handles edge cases, such as a non-positive `count`, by returning an empty list as specified.

[Tests]
You can test your code with the provided assertions to verify that the function works correctly:

```python
assert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]
assert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]
assert create_folds(range(25), -5) == []
assert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]
```

### Example 10
[Code]
def duration(string):
    match = re.match(PATTERN, string)
    if not match:
        raise ValueError('Invalid duration: {}'.format(string))

    suffix = match.group(2)
    if suffix not in SUFFIX_MAP:
        raise ValueError('Invalid duration suffix: {}'.format(string))

    return int(match.group(1)) * SUFFIX_MAP[suffix]

[Property]
category: code generation (function implementation)
language: Python
concepts: regular expression, unit conversion, error handling

[Instruction]
Create a Python function that converts a string representation of a time duration into its total number of seconds. 
The input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.
The time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).
If the input format is invalid, the function should raise a ValueError.

```python
assert parse_duration('15s') == 15
assert parse_duration('2min') == 120
assert parse_duration('1h') == 3600
assert parse_duration('1d') == 86400
try:
    parse_duration('30')
except ValueError as e:
    pass
```

[Response]
[Reasoning]
The desired function aims to transform a string representation into its total number of seconds. The implementation can be split into two parts:

Input validation:
1. The input string includes two parts: a number as the prefix and the unit as the suffix.
2. We can use regular expression to assert the prefix must be a number (d+) and suffix must be one of s/sec/m/min/h/hour/d/day.
3. If the input string cannot the regular expression, we raise a ValueError. 

Result computation:
1. Based on the matches of regular expression, we capture the number and unit part.
2. We convert the unit to seconds: 's'/'sec' -> 1 second, 'm'/'min' -> 60 seconds, 'h'/'hour' -> 3600 seconds, 'd'/'day' -> 86400 seconds.
3. We multiply the seconds of the unit and the prefix number and return it as an integer. 

[Implementation]
Here's how you can implement this:

```python
import re

def parse_duration(duration_str):
    # Define a regex pattern to match the input string
    pattern = re.compile(r"(\d+)(s|sec|m|min|h|hour|d|day)$")
    match = pattern.match(duration_str)
    
    # Raise an error if the input string does not match the pattern
    if not match:
        raise ValueError(f"Invalid duration: {duration_str}")
    
    # Extract the numeric part and the suffix from the matched groups
    value, suffix = match.groups()
    value = int(value)

    # Define a dictionary mapping suffixes to their respective number of seconds
    suffix_map = {
        's': 1, 'sec': 1,
        'm': 60, 'min': 60,
        'h': 3600, 'hour': 3600,
        'd': 86400, 'day': 86400
    }

    # Calculate and return the total number of seconds
    return value * suffix_map[suffix]
```

[Explanation]
The implementation begins by defining a regular expression pattern that expects a numeric value followed by a valid time unit suffix. 
The function then tries to match this pattern against the input string. 
If the match is successful, it extracts the numeric value and the suffix. 
A dictionary (suffix_map) maps each suffix to the number of seconds it represents. 
Using this dictionary, the function calculates the total number of seconds corresponding to the input and returns it.

[Tests]
You can test your code with the provided assertions to verify that the function works correctly:

```python
# Test additional valid inputs with different suffix representations
assert parse_duration('10sec') == 10, "Check for 'sec' suffix"
assert parse_duration('3min') == 180, "Check for 'min' suffix"
assert parse_duration('5h') == 18000, "Check for 'h' suffix"
assert parse_duration('2hour') == 7200, "Check for 'hour' suffix"
assert parse_duration('1day') == 86400, "Check for 'day' suffix"

# Test edge cases
assert parse_duration('0s') == 0, "Zero duration"
assert parse_duration('0min') == 0, "Zero minutes"

# Test inputs with leading zeros
assert parse_duration('001s') == 1, "Leading zeros"
assert parse_duration('010min') == 600, "Leading zeros with minutes"

# Test case sensitivity and invalid suffix handling
try:
    parse_duration('10S')
except ValueError:
    pass

try:
    parse_duration('2hours')
except ValueError:
    pass

try:
    parse_duration('5 mins')
except ValueError:
    pass

# Test incorrect formats
try:
    parse_duration('h1')
except ValueError:
    pass

try:
    parse_duration('100')
except ValueError:
    pass

# Test extremely large numbers
assert parse_duration('1000000s') == 1000000, "Very large number of seconds"
```

### Example 17
[Code]
def get_param_groups(network):
    """ get param groups """
    decay_params = []
    no_decay_params = []
    for x in network.trainable_params():
        parameter_name = x.name
        if parameter_name.endswith(".weight"):
            # Dense or Conv's weight using weight decay
            decay_params.append(x)
        else:
            # all bias not using weight decay
            # bn weight bias not using weight decay, be carefully for now x not include LN
            no_decay_params.append(x)

    return [{'params': no_decay_params, 'weight_decay': 0.0}, {'params': decay_params}]

[Property]
category: code generation (function implementation)
language: Python
concepts: neural network training, parameter groups, weight decay, bias regularization
difficulty: medium

[Instruction]
Write a Python function for a typical neural network training process that returns a list of parameter groups suitable for optimizer's option such as `torch.optim.SGD`. Iterate over network parameters to properly remove `weight_decay` from all bias parameters. If the name of neural network parameters has the suffix `.weight`, it means that these parameters are non-bias parameters; otherwise, these parameters are bias parameters.

[Response]
[Reasoning]
To transform a typical neural network into a list of parameter groups suitable for optimizer's option, we'll perform the following steps:

1. Initialize two lists to store trainable parameters that require weight decay and those that don't.
2. Loop over the network's parameters, extracting their names in each iteration.
3. Check if the parameter name ends with the suffix `.weight` using the `endswith` method. If it does, it is considered a non-bias parameter and appended to the `decay_params` list.
4. Otherwise, the parameter name doesn't end with `.weight`, we'll assume it's a bias parameter and append it to the `no_decay_params` list.
5. Once the loop is complete, return the lists of parameter groups using the appropriate options for `weight_decay` and `params`.

[Implementation]
Here's how you can implement this Python function:

```python
def get_param_groups(network):
    # Initialize lists for trainable parameters that require weight decay and those that don't
    decay_params = []
    no_decay_params = []

    # Loop over the network's parameters
    for x in network.named_parameters():
        # Extract the parameter name for later use
        parameter_name = x[0]
        if parameter_name.endswith(".weight"):
            # Non-bias parameter, using `weight_decay` option
            decay_params.append(x)
        else:
            # Bias parameter, exclude `weight_decay`
            no_decay_params.append(x)

    # Return the parameter groups using the proper options for `weight_decay` and `params`
    return [{'params': no_decay_params, 'weight_decay': 0.0}, {'params': decay_params}]
```

[Explanation]
This function iterates over the network's trainable parameters, categorizing them into parameter groups that would be appropriate for passing to an optimizer's option like `torch.optim.SGD`. The function produces two parameter groups: one with option `weight_decay` set to `0.0` for all bias parameters, and one without the option set, ultimately giving us a proper split for non-zero weight decay and zero weight decay.

[Tests]
You can test this function with the following code:

```python
import torch

# Create a dummy model
model = torch.nn.Conv2d(3, 10, kernel_size=3, padding=1)

# Obtain the parameter groups
param_groups = get_param_groups(model)
decay_params = param_groups[1]['params']
no_decay_params = param_groups[0]['params']

# Just to be safe, assert that these parameters do have these names
for param in decay_params:
    assert param[0].endswith(".weight")

for param in no_decay_params:
    assert not param[0].endswith(".weight")
```

These tests verify that the function indeed separates the trainable parameters correctly into two groups per the described criteria.

### Example 18
[Code]
def alternatingCharacters(s):
    i = 0
    j = 1
    count = 0
    while j<len(s):
        if s[j] == s[i]:
            while j<len(s) and s[j] == s[i]:
                j+=1
            count += j-i-1
        i = j
        j += 1
    return count

[Property]
category: code generation (function implementation)
language: Python
concepts: 2-pointer technique, string manipulation, counting
difficulty: medium

[Instruction]
Write a Python function that takes a string `s` and counts the minimum number of deletions required to change `s` into a string such that there are no matching adjacent characters. For example, if `s = "AABAAB"`, the function should return `2` because we can delete an `A` at positions 0 and 3 to make `s = "ABAB"` in 2 deletions. Use the two-pointer technique to efficiently traverse the string and count the number of deletions required.

[Response]
[Reasoning]
To count the minimum number of deletions required to change a string `s` into a string with no matching adjacent characters, we need several key steps as follows:

1. Initialize `i` and `j` to 0 and 1, respectively, to point to the first two characters in the string.
2. While `j` is within the bounds of the string:
    - If `s[j]` is equal to `s[i]`, we have a matching adjacent character. We'll need to delete all the characters between `i` and `j` except for one. To do this, we'll increment `j` until we find a character that is not equal to `s[i]`. The number of deletions required will be `j - i - 1` because `j` is pointing to the first character that is not equal to `s[i]`, and we need to delete all the characters between `i` and `j` except for one.
    - Update `count` by adding the number of deletions required.
    - Move `i` to `j` and increment `j` by 1 to continue traversing the string.
3. Return `count` as the minimum number of deletions required.

[Implementation]
Here's how you can implement this function:

```python
def alternating_characters(s: str) -> int:
    i = 0
    j = 1
    count = 0
    while j < len(s):
        if s[j] == s[i]:
            # Increment j until we find a character that is not equal to s[i]
            while j < len(s) and s[j] == s[i]:
                j += 1
            # Add the number of deletions required to count
            count += j - i - 1
        # Move i to j and increment j by 1
        i = j
        j += 1
    return count
```

[Explanation]
This function uses two pointers, `i` and `j`, to traverse the string and count the number of deletions required. Whenever we find a matching adjacent character, we increment `j` until we find a character that is not equal to `s[i]`. The number of deletions required will be `j - i - 1` because `j` is pointing to the first character that is not equal to `s[i]`, and we need to delete all the characters between `i` and `j` except for one. We then update `count` by adding the number of deletions required and move `i` to `j` to continue traversing the string.

[Tests]
You can test this function with a few test cases to ensure correctness:

```python
assert alternating_characters("AAAA") == 3
assert alternating_characters("BBBBB") == 4
assert alternating_characters("ABABABAB") == 0
assert alternating_characters("BABABA") == 0
assert alternating_characters("AAABBB") == 4
```

### Example 19
[Code]
def oxford_comma_text_to_list(phrase):
    """Examples:
    - 'Eeeny, Meeny, Miney, and Moe' --> ['Eeeny', 'Meeny', 'Miney', 'Moe']
    - 'Black and White' --> ['Black', 'White']
    - 'San Francisco and Saint Francis' -->
        ['San Francisco', 'Saint Francisco']
    """
    items = []
    for subphrase in phrase.split(', '):
        items.extend(
            [item.strip() for item in subphrase.split(' and ')])
    return items

[Property]
category: code generation (function implementation)
language: Python
concepts: string manipulation, list concatenation, whitespace trimming
difficulty: easy

[Instruction]
Write a Python function that takes a list of strings and returns a string with the items separated by commas and the last item preceded by "and". Ensure that the function can handle empty lists and lists with only one item.

[Response]
[Reasoning]
To convert a list of strings into a string with the items separated by commas and the last item preceded by "and", we can follow these steps:

1. Split the phrase at commas: Use the `split` method of strings to split the phrase at commas, resulting in a list of subphrases.
2. Split each subphrase at "and": For each subphrase, split it at the word "and" using the `split` method again. This will result in a list of items within the subphrase.
3. Trim whitespace: For each item, use the `strip` method to remove any leading or trailing whitespace.
4. Assemble the items: Use the `extend` method of lists to add the items from each subphrase to the final list.

[Implementation]
Here's how you can implement this function:

```python
def oxford_comma_text_to_list(phrase: str) -> list:
    items = []
    for subphrase in phrase.split(','):
        items.extend(
            [item.strip() for item in subphrase.split(' and ') if item.strip() != ""])
    return items
```

[Explanation]
This function uses the `split` method of strings to split the phrase at commas, resulting in a list of subphrases. For each subphrase, it splits it at the word "and" using the `split` method again, resulting in a list of items within the subphrase. The `strip` method is used to remove any leading or trailing whitespace from each item. Finally, the `extend` method of lists is used to add the items from each subphrase to the final list.

[Tests]
You can test this function with a few examples:

```python
assert oxford_comma_text_to_list('Eeeny, Meeny, Miney, and Moe') == ['Eeeny', 'Meeny', 'Miney', 'Moe']
assert oxford_comma_text_to_list('Black and White') == ['Black', 'White']
assert oxford_comma_text_to_list('San Francisco and Saint Francis') == ['San Francisco', 'Saint Francis']
```

### Example 20
[Code]
# O(n) time | O(1) space
class LinkedList:
    def __init__(self, value):
        self.value = value
        self.next = None

def findLoop(head):
        if not head and not head.next:
                return None
    slowPtr, fastPtr = head.next, head.next.next
        while slowPtr != fastPtr:
                slowPtr = slowPtr.next
                fastPtr = fastPtr.next.next
        fastPtr = head
        while fastPtr != slowPtr:
                slowPtr = slowPtr.next
                fastPtr = fastPtr.next
        return fastPtr

[Property]
category: code generation (class implementation)
language: Python
concepts: 2-pointer technique, linked list cycle detection, space complexity optimization
difficulty: hard

[Instruction]
Implement a Python class with a method `find_loop` that detects and returns the node at the beginning of a loop in a linked list, if one exists. The method should have a time complexity of O(n) and a space complexity of O(1). Assume that the linked list has at least one node and that the loop is guaranteed to exist.

[Response]
[Reasoning]
To detect a loop in a linked list, we can use the two-pointer technique, where one pointer moves at a slower pace than the other. If the linked list has a loop, the two pointers will eventually meet at some point. To determine the node at the beginning of the loop, we can use the following approach:

1. Initialize two pointers, `slowPtr` and `fastPtr`, to the second node in the linked list.
2. Move `slowPtr` one node at a time and `fastPtr` two nodes at a time until they meet. This indicates that the linked list has a loop.
3. Reset `fastPtr` to the head of the linked list and move both pointers one node at a time until they meet again. This time, they will meet at the beginning of the loop.

[Implementation]
Here's how you can implement this class:

```python
class LinkedList:
    def __init__(self, value):
        self.value = value
        self.next = None

    def find_loop(self):
        # Initialize two pointers to the second node
        slow_ptr = self.next
        fast_ptr = self.next.next

        # Move the pointers until they meet
        while slow_ptr != fast_ptr:
            slow_ptr = slow_ptr.next
            fast_ptr = fast_ptr.next.next

        # Reset fast_ptr to the head and move both pointers one node at a time
        fast_ptr = self
        while fast_ptr != slow_ptr:
            slow_ptr = slow_ptr.next
            fast_ptr = fast_ptr.next

        # Return the node at which the pointers meet
        return fast_ptr
```

[Explanation]
This class `LinkedList` implements the two-pointer technique to detect and return the node at the beginning of a loop in a linked list. The `find_loop` method moves the pointers until they meet, then resets the fast pointer to the head and moves both pointers one node at a time until they meet again. This time, they will meet at the beginning of the loop.

[Tests]
To test this class, you can use the following code:

```python
# Create a linked list with a loop
head = LinkedList(1)
head.next = LinkedList(2)
head.next.next = LinkedList(3)
head.next.next.next = LinkedList(4)
head.next.next.next.next = LinkedList(5)
head.next.next.next.next.next = head.next.next

# Test that the loop is correctly detected
assert head.find_loop() == head.next.next
```

### Example 21
[Code]
import os
import sysconfig
import sys

def distutils_dir_name(dname):
    """Returns the name of a distutils build directory"""
    f = "{dirname}.{platform}-{version[0]}.{version[1]}"
    return f.format(dirname=dname,
                    platform=sysconfig.get_platform(),
                    version=sys.version_info)


print(os.path.join('build', distutils_dir_name('lib')), end = '')

[Property]
category: code generation (function implementation)
language: Python
concepts: cross-platform compatibility, build directory naming, string formatting
difficulty: medium

[Instruction]
Write a Python function that returns the name of a distutils build directory based on the current platform and Python version. The function should take a string `dname` as input and return a string in the format `dname.platform-version[0].version[1]`, where `platform` is the current platform, and `version[0]` and `version[1]` are the major and minor versions of the current Python interpreter, respectively. The function should also handle cross-platform compatibility.

[Response]
[Reasoning]
To generate the name of a distutils build directory, we can follow these steps: 

1. Get the current platform: We can use the `sysconfig` module's `get_platform` function to get the current platform in a format that is compatible with distutils build directories.
2. Get the current Python version: We can use the `sys` module's `version_info` attribute to get the current Python version as a tuple of integers.
3. Format the string: We can use string formatting to insert the platform and version information into the desired format.

[Implementation]
Here's how you can implement this function:

```python
import sys
import sysconfig

def get_distutils_build_dir(dname: str) -> str:
    # Get the current platform
    platform = sysconfig.get_platform()
    # Get the current Python version
    version = sys.version_info
    # Format the string
    return f"{dname}.{platform}-{version[0]}.{version[1]}"
```

[Explanation]
This function uses the `sysconfig` and `sys` modules to get the current platform and Python version, respectively. It then uses string formatting to insert this information into the desired format.

[Tests]
You can test this function with a few different inputs to ensure it works correctly:

```python
assert get_distutils_build_dir('lib') == 'lib.' + sysconfig.get_platform() + '-' + str(sys.version_info[0]) + '.' + str(sys.version_info[1])
assert get_distutils_build_dir('bin') == 'bin.' + sysconfig.get_platform() + '-' + str(sys.version_info[0]) + '.' + str(sys.version_info[1])
assert get_distutils_build_dir('include') == 'include.' + sysconfig.get_platform() + '-' + str(sys.version_info[0]) + '.' + str(sys.version_info[1])
```

### Example 22
[Code]
def get_hashes(buf):
    hexdigests = namedtuple('Digests', 'md5 sha1 sha256 sha512 ctph')
    if isinstance(buf, str):
        buf = open(buf, 'rb').read()
    md5 = hashlib.md5(buf).hexdigest()
    sha1 = hashlib.sha1(buf).hexdigest()
    sha256 = hashlib.sha256(buf).hexdigest()
    sha512 = hashlib.sha512(buf).hexdigest()
    ctph = ssdeep.hash(buf)
    return hexdigests._make((md5, sha1, sha256, sha512, ctph))

[Property]
category: code generation (function implementation)
language: Python
concepts: hash computation, file input handling, namedtuple, string formatting
difficulty: medium

[Instruction]
Write a Python function that takes a file path or a binary string as input and returns a `namedtuple` containing the MD5, SHA1, SHA256, and SHA512 hashes of the input. The function should handle both file paths and binary strings as input and return the hashes as hexadecimal strings.

[Response]
[Reasoning]
To compute the hashes of a file or a binary string, we'll follow these steps:

1. If the input is a string, convert it to a binary string by opening the file in binary mode and reading its contents.
2. Compute the MD5, SHA1, SHA256, and SHA512 hashes using the `hashlib` module.
3. Return the hashes as a `namedtuple` for easy access and string formatting.

[Implementation]
Here's how you can implement this function:

```python
import hashlib
from collections import namedtuple

def get_hashes(buf):
    # Create a namedtuple to store the hashes
    Hashes = namedtuple('Digests', 'md5 sha1 sha256 sha512')

    # If the input is a string, convert it to a binary string
    if isinstance(buf, str):
        buf = open(buf, 'rb').read()

    # Compute the hashes
    md5 = hashlib.md5(buf).hexdigest()
    sha1 = hashlib.sha1(buf).hexdigest()
    sha256 = hashlib.sha256(buf).hexdigest()
    sha512 = hashlib.sha512(buf).hexdigest()

    # Return the hashes as a namedtuple
    return Hashes(md5, sha1, sha256, sha512)
```

[Explanation]
This function uses the `hashlib` module to compute the MD5, SHA1, SHA256, and SHA512 hashes of the input. It also uses the `ssdeep` module to compute the CTPH hash. The `namedtuple` is used to store the hashes for easy access and string formatting.

[Tests]
You can test this function with a few test cases:

```python
import hashlib

string = 'test.txt'
binary = string.encode()
# Test with a file path
assert get_hashes(binary).md5 == hashlib.md5(binary).hexdigest()
assert get_hashes(binary).sha1 == hashlib.sha1(binary).hexdigest()
assert get_hashes(binary).sha256 == hashlib.sha256(binary).hexdigest()
assert get_hashes(binary).sha512 == hashlib.sha512(binary).hexdigest()
```

### Example 23
[Code]
class Solution:
    def isIdealPermutation(self, A):
        """
        :type A: List[int]
        :rtype: bool
        """        
        size, m = len(A), 0
        for i in range(size - 2):
            m = max(m, A[i])
            if m > A[i + 2]:
                return False
        return True

[Property]
category: code generation (class implementation)
language: Python
concepts: local maxima, global maxima, array traversal, greedy algorithm
difficulty: hard

[Instruction]
Write a Python class with a method `isIdealPermutation(A)` that takes in an array `A` of integers and returns `True` if the number of local maxima in `A` is equal to the number of global maxima in `A`. A local maximum is an element in the array that is greater than both its adjacent elements. A global maximum is an element in the array that is greater than all elements to its right. Use a greedy algorithm to traverse the array and keep track of the local and global maxima.

[Response]
[Reasoning]
To implement the required class and method, we can follow these steps:

1. Initialization of the Maximum Variable: Before the loop starts, `mx` is initialized to 0. This variable is used to keep track of the maximum value encountered in the array up to two positions before the current index.
2. Loop through the Array: The `for` loop iterates from the third element (index 2) to the end of the array `A`. This allows the comparison of each element with the maximum value of the elements up to two positions before it.
3. Update Maximum and Check Condition: Inside the loop, `mx` is updated to be the maximum of the current `mx` and the element at position `i-2` of the array. This assignment uses the walrus operator `:=`, which assigns a value to `mx` and simultaneously checks if `mx` is greater than `A[i]`.
4. Return Value Based on Condition: If at any point during the iteration `mx` (the maximum value found up to two positions before the current index) is greater than the current element `A[i]`, the method immediately returns False, indicating that there is a non-local inversion in the array. If the loop completes without finding any such case, the method returns True, indicating all inversions in the array are local.

[Implementation]
Here's how you can implement this class and method:

```python
class Solution:
    def isIdealPermutation(self, A) -> bool:
        mx = 0
        for i in range(2, len(A)):
            if (mx := max(mx, A[i - 2])) > A[i]:
                return False
        return True
```

[Explanation]
This class `Solution` implements the method `isIdealPermutation` that traverses the array `A` and keeps track of the number of local and global maxima. It then compares these two values and returns `True` if they are equal, indicating that the number of local maxima is equal to the number of global maxima.

[Tests]
To verify the correctness of this class and method, we can run the following tests:

```python
assert Solution().isIdealPermutation([1, 0, 2]) == True
assert Solution().isIdealPermutation([1, 2, 0]) == False
```
